[
  {
    "id" : "eaad130d-de50-43e2-b8af-702fa53bbd31",
    "prId" : 7818,
    "comments" : [
      {
        "id" : "7789a386-6a02-4c9a-ade4-06acebb3fc09",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    val builder = Iterable.newBuilder[(SDefinitionRef, SDefinition)]\r\n```\r\n\r\nplus: \r\n+ change the `topLevelFunction` method as follows: \r\n```scala\r\n  private[this] def topLevelFunction[SDefRef <: SDefinitionRef: LabelModule.Allowed](\r\n      ref: SDefRef,\r\n      arity: Int)(\r\n      body: List[Position] => SExpr\r\n  ): (SDefRef, SDefintion) =\r\nref ->\r\n      SDefinition(\r\n         unsafeClosureConvert(\r\n            SEAbs(arity, withLabel(ref, body(List.fill(arity)(nextPosition()))))\r\n        )\r\n   )\r\n```\r\n+ some other type signatures (where `SExpr` -> `SDefinition`) ",
        "createdAt" : "2020-10-27T17:17:34Z",
        "updatedAt" : "2020-10-28T11:56:46Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "931962f7-09f7-46da-950e-7ff6404f8195",
        "parentId" : "7789a386-6a02-4c9a-ade4-06acebb3fc09",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "I considered this, but thought it was cleaner to just wrap it in one place. Iâ€™ll give it a try tomorrow though.",
        "createdAt" : "2020-10-27T17:28:00Z",
        "updatedAt" : "2020-10-28T11:56:46Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02ccc385-e4aa-4938-8cc2-ee2d7494b8aa",
        "parentId" : "7789a386-6a02-4c9a-ade4-06acebb3fc09",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "With the change I suggest, you wrap it in only ~one~ two places.\r\nDo what you think it is the best. I am fine with merging the PR such as. ",
        "createdAt" : "2020-10-27T17:30:01Z",
        "updatedAt" : "2020-10-28T11:56:46Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c65935dd-3338-4338-90f3-0033bb450a01",
        "parentId" : "7789a386-6a02-4c9a-ade4-06acebb3fc09",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-10-28T10:00:05Z",
        "updatedAt" : "2020-10-28T11:56:46Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6eba0fb6577aa5e7b5e54534bbcfe658c81cbdd9",
    "line" : null,
    "diffHunk" : "@@ -256,7 +256,7 @@ private[lf] final class Compiler(\n   def unsafeCompileModule(\n       pkgId: PackageId,\n       module: Module,\n-  ): Iterable[(SDefinitionRef, SExpr)] = {\n+  ): Iterable[(SDefinitionRef, SDefinition)] = {\n     val builder = Iterable.newBuilder[(SDefinitionRef, SExpr)]"
  },
  {
    "id" : "4fffe6b6-8bc2-468f-8ae9-bcd445d495ef",
    "prId" : 7818,
    "comments" : [
      {
        "id" : "e24e92df-3784-4e83-8d20-295297f0f8bb",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    builder.result()\r\n```",
        "createdAt" : "2020-10-27T17:20:19Z",
        "updatedAt" : "2020-10-28T11:56:46Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6eba0fb6577aa5e7b5e54534bbcfe658c81cbdd9",
    "line" : null,
    "diffHunk" : "@@ -277,11 +277,15 @@ private[lf] final class Compiler(\n         tmpl.key.foreach { tmplKey =>\n           builder += compileFetchByKey(identifier, tmpl, tmplKey)\n           builder += compileLookupByKey(identifier, tmplKey)\n-          tmpl.choices.values.foreach(builder += compileChoiceByKey(identifier, tmpl, tmplKey, _))\n+          tmpl.choices.values.foreach(\n+            builder +=\n+              compileChoiceByKey(identifier, tmpl, tmplKey, _))\n         }\n     }\n \n-    builder.result()\n+    builder\n+      .result()\n+      .map { case (ref, body) => ref -> SDefinition(body) }"
  },
  {
    "id" : "1442896e-cb71-410f-a47c-8d6512c49d4a",
    "prId" : 7778,
    "comments" : [
      {
        "id" : "fa6323fa-0e04-4fbe-8e81-ec877f5cfd56",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Why not something like: \r\n\r\n```scala\r\n   val builtin = structProj.fieldIndex.fold(SBStructProjByName(structProj.field))(SBStructProj)\r\n   builtin.apply(compile(structProj.struct))\r\n```",
        "createdAt" : "2020-10-22T12:08:32Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "33791aab-2921-4a9d-9de7-2d123dc947d6",
        "parentId" : "fa6323fa-0e04-4fbe-8e81-ec877f5cfd56",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I simply don't like `fold` on `Option`. Whenever I see `fold`, I need to stop for a moment and run a type inference in my head. I don't need to do this with pattern matching. Thus, I'm avoiding to produce code I _personally_ find harder to read, although I won't stop others from using `fold`.",
        "createdAt" : "2020-10-22T12:17:37Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "17b1cbc0-ab3d-416f-9278-1e15f89a4d23",
        "parentId" : "fa6323fa-0e04-4fbe-8e81-ec877f5cfd56",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "No problem, it was just a suggestion. ",
        "createdAt" : "2020-10-22T12:19:37Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cbc86fa8-fd3d-4edf-b804-b5430dab3bf1",
        "parentId" : "fa6323fa-0e04-4fbe-8e81-ec877f5cfd56",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I know. Apologies if I came across as aggressive!\r\n\r\nMy goal was to share my motivation for doing things the way I do them. ðŸ˜ƒ ",
        "createdAt" : "2020-10-22T12:34:30Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6ef549582f052ca0d9abd09ff2f154d159b01849",
    "line" : 9,
    "diffHunk" : "@@ -376,16 +376,13 @@ private[lf] final class Compiler(\n         )\n       case structProj: EStructProj =>\n         structProj.fieldIndex match {\n-          case None =>\n-            throw CompilationError(\n-              s\"structural record projection for field ${structProj.field} has no index\")\n+          case None => SBStructProjByName(structProj.field)(compile(structProj.struct))\n           case Some(index) => SBStructProj(index)(compile(structProj.struct))\n         }"
  },
  {
    "id" : "11c1f3fa-26ea-4616-b3dc-49b92163825b",
    "prId" : 7740,
    "comments" : [
      {
        "id" : "b4a762e4-7dca-4330-a566-bef1b8dbd0c1",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n      case strucProj: EStructProj =>\r\n        strucProj.fieldIndex match {\r\n          case None => throw CompilationError(s\"structural record projection for field ${field} has no index\")\r\n          case Some(index) => SBStructProj(index)(compile(strucProj.struct))\r\n        }\r\n```",
        "createdAt" : "2020-10-19T14:42:47Z",
        "updatedAt" : "2020-10-19T18:09:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c9ff02de54582aa2ae4421ef2c53adf9307ee16",
    "line" : null,
    "diffHunk" : "@@ -374,8 +374,11 @@ private[lf] final class Compiler(\n           SEBuiltin(SBStructCon(fieldsInputOrder)),\n           fields.iterator.map { case (_, e) => compile(e) }.toArray\n         )\n-      case EStructProj(field, struct) =>\n-        SBStructProj(field)(compile(struct))\n+      case EStructProj(field @ _, fieldIndex, struct) =>\n+        fieldIndex match {\n+          case None => throw CompilationError(s\"structural record projection for field ${field} has no index\")\n+          case Some(index) => SBStructProj(index)(compile(struct))\n+        }"
  },
  {
    "id" : "bd67b45b-f3e4-42c8-b43c-8631192442fa",
    "prId" : 7548,
    "comments" : [
      {
        "id" : "f4ee7695-2252-4cfa-9866-9c6130fa86e8",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n            val observers = choice.observers match {\r\n              case Some(observers) => compile(observers)\r\n              case None => SValue.SValue.EmptyList\r\n            }\r\n```",
        "createdAt" : "2020-10-15T07:35:13Z",
        "updatedAt" : "2020-10-21T08:55:23Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1968095863437d26708412e9478b8d076d85897c",
    "line" : null,
    "diffHunk" : "@@ -887,6 +887,13 @@ private[lf] final class Compiler(\n           {\n             addExprVar(choice.argBinder._1, choiceArgPos)\n             compile(choice.controllers)\n+          }, //\n+          {\n+            val observers = choice.observers match {\n+              case Some(observers) => observers\n+              case None => ENil(TBuiltin(BTParty))\n+            }\n+            compile(observers)"
  },
  {
    "id" : "f5edf014-558e-4251-a03f-b42094946a8e",
    "prId" : 7502,
    "comments" : [
      {
        "id" : "169678cc-0542-4f39-80d7-7fa8030825a5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why we used a list here? A map seems like a much more natural choice and better in basically every regard so I wonder if Iâ€™m missing something here.",
        "createdAt" : "2020-09-29T09:34:55Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8d31a2f1-8bfb-4cb0-add3-7904e7d47085",
        "parentId" : "169678cc-0542-4f39-80d7-7fa8030825a5",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I think the original idea was to represent a stack and to be able to \"pop\" the changes made to it. \r\nIn the current design this is not used, so better a `Map`.  ",
        "createdAt" : "2020-09-29T11:04:02Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : 87,
    "diffHunk" : "@@ -135,45 +135,56 @@ private[lf] final class Compiler(\n   // corresponds to DAML-LF type variable.\n   private[this] case class TVarRef(name: TypeVarName) extends VarRef\n \n-  private[this] case class Env(\n-      position: Int = 0,\n-      varIndices: List[(VarRef, Option[Int])] = List.empty,\n-  ) {\n-    def incrPos: Env = copy(position = position + 1)\n-    def addExprVar(name: Option[ExprVarName], index: Int): Env =\n-      name.fold(this)(n => copy(varIndices = (EVarRef(n), Some(index)) :: varIndices))\n-    def addExprVar(name: ExprVarName, index: Int): Env =\n-      addExprVar(Some(name), index)\n-    def addExprVar(name: Option[ExprVarName]): Env =\n-      incrPos.addExprVar(name, position)\n-    def addExprVar(name: ExprVarName): Env =\n-      addExprVar(Some(name))\n-    def addTypeVar(name: TypeVarName): Env =\n-      incrPos.copy(varIndices = (TVarRef(name), Some(position)) :: varIndices)\n-    def hideTypeVar(name: TypeVarName): Env =\n-      copy(varIndices = (TVarRef(name), None) :: varIndices)\n-\n-    def vars: List[VarRef] = varIndices.map(_._1)\n-\n-    private[this] def lookUpVar(varRef: VarRef): Option[Int] =\n-      varIndices\n-        .find(_._1 == varRef)\n-        .flatMap(_._2)\n-        // The de Bruijin index for the binder, e.g.\n-        // the distance to the binder. The closest binder\n-        // is at distance 1.\n-        .map(position - _)\n-\n-    def lookUpExprVar(name: ExprVarName): Int =\n-      lookUpVar(EVarRef(name))\n-        .getOrElse(\n-          throw CompilationError(s\"Unknown variable: $name. Known: ${env.vars.mkString(\",\")}\"))\n-\n-    def lookUpTypeVar(name: TypeVarName): Option[Int] =\n-      lookUpVar(TVarRef(name))\n+  case class Position(idx: Int)\n+\n+  @inline\n+  private[this] def nextPosition(): Position = {\n+    val p = env.position\n+    env = env.copy(position = env.position + 1)\n+    Position(p)\n+  }\n \n+  @inline\n+  private[this] def nextPosition(name: ExprVarName): Position = {\n+    val p = nextPosition()\n+    addExprVar(name, p)\n+    p\n   }\n \n+  private[this] def nextPosition(name: Option[ExprVarName]): Position =\n+    name.fold(nextPosition())(nextPosition)\n+\n+  private[this] def svar(p: Position): SEVar = SEVar(env.position - p.idx)\n+\n+  private[this] def addVar(ref: VarRef, position: Position) =\n+    env = env.copy(varIndices = env.varIndices.updated(ref, position))\n+\n+  private[this] def addExprVar(name: ExprVarName, position: Position) =\n+    addVar(EVarRef(name), position)\n+\n+  private[this] def addTypeVar(name: TypeVarName, position: Position) =\n+    addVar(TVarRef(name), position)\n+\n+  private[this] def hideTypeVar(name: TypeVarName) =\n+    env = env.copy(varIndices = env.varIndices - TVarRef(name))\n+\n+  private[this] def vars: List[VarRef] = env.varIndices.keys.toList\n+\n+  private[this] def lookUpVar(varRef: VarRef): Option[SEVar] =\n+    env.varIndices.get(varRef).map(svar)\n+\n+  def lookUpExprVar(name: ExprVarName): SEVar =\n+    lookUpVar(EVarRef(name))\n+      .getOrElse(throw CompilationError(s\"Unknown variable: $name. Known: ${vars.mkString(\",\")}\"))\n+\n+  def lookUpTypeVar(name: TypeVarName): Option[SEVar] =\n+    lookUpVar(TVarRef(name))\n+\n+  private[this] case class Env(\n+      position: Int = 0,\n+      varIndices: Map[VarRef, Position] = Map.empty,"
  },
  {
    "id" : "8f57446b-7fcf-416a-a7d2-1e004729e911",
    "prId" : 7502,
    "comments" : [
      {
        "id" : "c482998e-9817-4652-8dce-1ad765902bba",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If we have an overload for `exprVar` should we also have an overload for typevar? (or a helper, as mentioned above, Iâ€™m not entirely convinced the overload is helpful).",
        "createdAt" : "2020-09-29T09:37:57Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bd9b4848-1401-426f-97d5-b955f530d6fe",
        "parentId" : "c482998e-9817-4652-8dce-1ad765902bba",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "no more overload.",
        "createdAt" : "2020-09-29T11:13:27Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : 141,
    "diffHunk" : "@@ -690,13 +695,13 @@ private[lf] final class Compiler(\n   private[this] def compileAbss(expr0: Expr, arity: Int = 0): SExpr =\n     expr0 match {\n       case EAbs((binder, typ @ _), body, ref @ _) =>\n-        env = env.addExprVar(binder)\n+        nextPosition(binder)\n         compileAbss(body, arity + 1)\n       case ETyAbs((binder, KNat), body) =>\n-        env = env.addTypeVar(binder)\n+        addTypeVar(binder, nextPosition())"
  },
  {
    "id" : "1d245ef0-7317-4ed4-b147-0dca969b674a",
    "prId" : 7502,
    "comments" : [
      {
        "id" : "9af33fa9-51f3-42d6-a75b-6915afc16765",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not a huge fan of this overload. `addExprVar` or something like that seems easier to understand (I realize we already use that name, either inline it here if possible or find something else).",
        "createdAt" : "2020-09-29T09:38:14Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "199f9f83-949a-401d-ac0b-d92c24666b00",
        "parentId" : "9af33fa9-51f3-42d6-a75b-6915afc16765",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I dropped the overload.",
        "createdAt" : "2020-09-29T11:11:25Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : null,
    "diffHunk" : "@@ -135,45 +135,56 @@ private[lf] final class Compiler(\n   // corresponds to DAML-LF type variable.\n   private[this] case class TVarRef(name: TypeVarName) extends VarRef\n \n-  private[this] case class Env(\n-      position: Int = 0,\n-      varIndices: List[(VarRef, Option[Int])] = List.empty,\n-  ) {\n-    def incrPos: Env = copy(position = position + 1)\n-    def addExprVar(name: Option[ExprVarName], index: Int): Env =\n-      name.fold(this)(n => copy(varIndices = (EVarRef(n), Some(index)) :: varIndices))\n-    def addExprVar(name: ExprVarName, index: Int): Env =\n-      addExprVar(Some(name), index)\n-    def addExprVar(name: Option[ExprVarName]): Env =\n-      incrPos.addExprVar(name, position)\n-    def addExprVar(name: ExprVarName): Env =\n-      addExprVar(Some(name))\n-    def addTypeVar(name: TypeVarName): Env =\n-      incrPos.copy(varIndices = (TVarRef(name), Some(position)) :: varIndices)\n-    def hideTypeVar(name: TypeVarName): Env =\n-      copy(varIndices = (TVarRef(name), None) :: varIndices)\n-\n-    def vars: List[VarRef] = varIndices.map(_._1)\n-\n-    private[this] def lookUpVar(varRef: VarRef): Option[Int] =\n-      varIndices\n-        .find(_._1 == varRef)\n-        .flatMap(_._2)\n-        // The de Bruijin index for the binder, e.g.\n-        // the distance to the binder. The closest binder\n-        // is at distance 1.\n-        .map(position - _)\n-\n-    def lookUpExprVar(name: ExprVarName): Int =\n-      lookUpVar(EVarRef(name))\n-        .getOrElse(\n-          throw CompilationError(s\"Unknown variable: $name. Known: ${env.vars.mkString(\",\")}\"))\n-\n-    def lookUpTypeVar(name: TypeVarName): Option[Int] =\n-      lookUpVar(TVarRef(name))\n+  case class Position(idx: Int)\n+\n+  @inline\n+  private[this] def nextPosition(): Position = {\n+    val p = env.position\n+    env = env.copy(position = env.position + 1)\n+    Position(p)\n+  }\n \n+  @inline\n+  private[this] def nextPosition(name: ExprVarName): Position = {"
  },
  {
    "id" : "a3eddefd-5230-4415-afab-9782b4374ed5",
    "prId" : 7502,
    "comments" : [
      {
        "id" : "8810ded0-6850-4704-864c-fee4f1a9fbd8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n  private[this] def lookupVar(varRef: VarRef): Option[SEVar] =\r\n```",
        "createdAt" : "2020-09-29T09:39:40Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "abef8d0b-1282-40c7-9730-0501ff89feaf",
        "parentId" : "8810ded0-6850-4704-864c-fee4f1a9fbd8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed.",
        "createdAt" : "2020-09-29T11:12:09Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : null,
    "diffHunk" : "@@ -135,45 +135,56 @@ private[lf] final class Compiler(\n   // corresponds to DAML-LF type variable.\n   private[this] case class TVarRef(name: TypeVarName) extends VarRef\n \n-  private[this] case class Env(\n-      position: Int = 0,\n-      varIndices: List[(VarRef, Option[Int])] = List.empty,\n-  ) {\n-    def incrPos: Env = copy(position = position + 1)\n-    def addExprVar(name: Option[ExprVarName], index: Int): Env =\n-      name.fold(this)(n => copy(varIndices = (EVarRef(n), Some(index)) :: varIndices))\n-    def addExprVar(name: ExprVarName, index: Int): Env =\n-      addExprVar(Some(name), index)\n-    def addExprVar(name: Option[ExprVarName]): Env =\n-      incrPos.addExprVar(name, position)\n-    def addExprVar(name: ExprVarName): Env =\n-      addExprVar(Some(name))\n-    def addTypeVar(name: TypeVarName): Env =\n-      incrPos.copy(varIndices = (TVarRef(name), Some(position)) :: varIndices)\n-    def hideTypeVar(name: TypeVarName): Env =\n-      copy(varIndices = (TVarRef(name), None) :: varIndices)\n-\n-    def vars: List[VarRef] = varIndices.map(_._1)\n-\n-    private[this] def lookUpVar(varRef: VarRef): Option[Int] =\n-      varIndices\n-        .find(_._1 == varRef)\n-        .flatMap(_._2)\n-        // The de Bruijin index for the binder, e.g.\n-        // the distance to the binder. The closest binder\n-        // is at distance 1.\n-        .map(position - _)\n-\n-    def lookUpExprVar(name: ExprVarName): Int =\n-      lookUpVar(EVarRef(name))\n-        .getOrElse(\n-          throw CompilationError(s\"Unknown variable: $name. Known: ${env.vars.mkString(\",\")}\"))\n-\n-    def lookUpTypeVar(name: TypeVarName): Option[Int] =\n-      lookUpVar(TVarRef(name))\n+  case class Position(idx: Int)\n+\n+  @inline\n+  private[this] def nextPosition(): Position = {\n+    val p = env.position\n+    env = env.copy(position = env.position + 1)\n+    Position(p)\n+  }\n \n+  @inline\n+  private[this] def nextPosition(name: ExprVarName): Position = {\n+    val p = nextPosition()\n+    addExprVar(name, p)\n+    p\n   }\n \n+  private[this] def nextPosition(name: Option[ExprVarName]): Position =\n+    name.fold(nextPosition())(nextPosition)\n+\n+  private[this] def svar(p: Position): SEVar = SEVar(env.position - p.idx)\n+\n+  private[this] def addVar(ref: VarRef, position: Position) =\n+    env = env.copy(varIndices = env.varIndices.updated(ref, position))\n+\n+  private[this] def addExprVar(name: ExprVarName, position: Position) =\n+    addVar(EVarRef(name), position)\n+\n+  private[this] def addTypeVar(name: TypeVarName, position: Position) =\n+    addVar(TVarRef(name), position)\n+\n+  private[this] def hideTypeVar(name: TypeVarName) =\n+    env = env.copy(varIndices = env.varIndices - TVarRef(name))\n+\n+  private[this] def vars: List[VarRef] = env.varIndices.keys.toList\n+\n+  private[this] def lookUpVar(varRef: VarRef): Option[SEVar] ="
  },
  {
    "id" : "93fee128-9f37-4d97-bf9d-d315740886a3",
    "prId" : 7493,
    "comments" : [
      {
        "id" : "829d1239-1a0e-4e3d-9ad0-1d3594627e45",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Is it better to call `SELet1` ?",
        "createdAt" : "2020-09-30T13:43:27Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "165bbf41-384a-4cd7-8e3a-b25b7e730eb1",
        "parentId" : "829d1239-1a0e-4e3d-9ad0-1d3594627e45",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Do we now use `SELet` anywhere? Can we drop it?",
        "createdAt" : "2020-09-30T14:18:25Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c094529d-11a5-480f-993e-dc6526a7f420",
        "parentId" : "829d1239-1a0e-4e3d-9ad0-1d3594627e45",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Why not `SELet` ? in any case on another PR.  ",
        "createdAt" : "2020-09-30T14:21:05Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "95d2fe39-3ecc-40cb-b0ef-d5def8a9ae3e",
        "parentId" : "829d1239-1a0e-4e3d-9ad0-1d3594627e45",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "@dajmaki we will drop the SELet in another PR. \r\n",
        "createdAt" : "2020-09-30T14:28:34Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : 50,
    "diffHunk" : "@@ -211,6 +206,37 @@ private[lf] final class Compiler(\n       case None => expr\n     }\n \n+  @inline\n+  private[this] def app(f: SExpr, a: SExpr) = SEApp(f, Array(a))\n+\n+  @inline\n+  private[this] def let(bound: SExpr)(body: Position => SExpr) =\n+    SELet1General(bound, body(nextPosition()))"
  },
  {
    "id" : "35478ea8-0a64-4ba1-8b25-83ffba73d72c",
    "prId" : 7493,
    "comments" : [
      {
        "id" : "33fe2c50-49a6-4cf6-b54a-389777195f4a",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I'm always dubious about the value of adding `@inline` especially as we have no perf stats to indicate they actually have any benefit, or even that they don't harm. We just seem to add them sometimes when we think the methods look _small enough_. But surely the JVM compiler would be the better judge of that :shrug: \r\n",
        "createdAt" : "2020-09-30T13:46:44Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "365ff800-64bb-4fe8-b286-46ac82fdee34",
        "parentId" : "33fe2c50-49a6-4cf6-b54a-389777195f4a",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I remove the one I added. ",
        "createdAt" : "2020-09-30T14:25:29Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : null,
    "diffHunk" : "@@ -146,39 +143,37 @@ private[lf] final class Compiler(\n   }\n \n   @inline\n-  private[this] def nextPositionWithExprName(name: ExprVarName): Position = {\n-    val p = nextPosition()\n-    addExprVar(name, p)\n-    p\n-  }\n-\n-  private[this] def nextPositionWithOptionalExprName(name: Option[ExprVarName]): Position =\n-    name.fold(nextPosition())(nextPositionWithExprName)\n-\n   private[this] def svar(p: Position): SEVar = SEVar(env.position - p.idx)\n \n+  @inline\n   private[this] def addVar(ref: VarRef, position: Position) =\n     env = env.copy(varIndices = env.varIndices.updated(ref, position))\n \n+  @inline\n   private[this] def addExprVar(name: ExprVarName, position: Position) =\n     addVar(EVarRef(name), position)\n \n+  @inline\n   private[this] def addTypeVar(name: TypeVarName, position: Position) =\n     addVar(TVarRef(name), position)\n \n+  @inline\n   private[this] def hideTypeVar(name: TypeVarName) =\n     env = env.copy(varIndices = env.varIndices - TVarRef(name))\n \n   private[this] def vars: List[VarRef] = env.varIndices.keys.toList\n \n+  @inline\n   private[this] def lookupVar(varRef: VarRef): Option[SEVar] =\n     env.varIndices.get(varRef).map(svar)\n \n-  def lookupExprVar(name: ExprVarName): SEVar =\n+  @inline\n+  private[this] def lookupExprVar(name: ExprVarName): SEVar =\n     lookupVar(EVarRef(name))\n       .getOrElse(throw CompilationError(s\"Unknown variable: $name. Known: ${vars.mkString(\",\")}\"))\n \n-  def lookupTypeVar(name: TypeVarName): Option[SEVar] =\n+  @inline"
  },
  {
    "id" : "f5eb20ae-5e46-4adf-ab59-0fa997b1521f",
    "prId" : 7493,
    "comments" : [
      {
        "id" : "4c5d8700-81e0-425a-bdfc-db588b9817a4",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "`\"getPArty\"` with a capital `A` !! (I realise it was like this before)",
        "createdAt" : "2020-09-30T13:48:40Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b509d70e-729b-4669-96a2-ed0c0c5eaa0c",
        "parentId" : "4c5d8700-81e0-425a-bdfc-db588b9817a4",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "good catch! ",
        "createdAt" : "2020-09-30T14:25:56Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : null,
    "diffHunk" : "@@ -790,53 +789,47 @@ private[lf] final class Compiler(\n     //       <r> = $catch ([update] <token>) true false\n     //   in $endCommit(mustFail = true) <r> <token>\n     withEnv { _ =>\n-      withLabel(\n-        \"submitMustFail\",\n-        SEAbs(1) {\n-          val tokenPos = nextPosition()\n-          val beginCommit = SBSBeginCommit(optLoc)(compile(party), svar(tokenPos))\n-          nextPosition()\n-          val result =\n-            SECatch(SEApp(compile(update), Array(svar(tokenPos))), SEValue.True, SEValue.False)\n-          val resultPos = nextPosition()\n-\n-          SELet(\n-            beginCommit,\n-            result,\n-          ) in SBSEndCommit(mustFail = true)(svar(resultPos), svar(tokenPos))\n+      labeledFunction(\"submitMustFail\") { tokenPos =>\n+        let(SBSBeginCommit(optLoc)(compile(party), svar(tokenPos))) { _ =>\n+          let(SECatch(app(compile(update), svar(tokenPos)), SEValue.True, SEValue.False)) {\n+            resultPos =>\n+              SBSEndCommit(mustFail = true)(svar(resultPos), svar(tokenPos))\n+          }\n         }\n-      )\n+      }\n     }\n \n   @inline\n   private[this] def compileGetParty(expr: Expr): SExpr =\n-    function(1, \"getPArty\") {\n-      case List(tokenPos) => SBSGetParty(compile(expr), svar(tokenPos))\n+    labeledFunction(\"getPArty\") { tokenPos =>"
  },
  {
    "id" : "487d0964-253c-4d01-9f0b-7c08e1d31439",
    "prId" : 7493,
    "comments" : [
      {
        "id" : "83b05b1f-7c63-4676-a8fd-abc3c2005cd0",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I really like the look of this! :+1: ",
        "createdAt" : "2020-09-30T13:51:50Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : 218,
    "diffHunk" : "@@ -759,28 +769,17 @@ private[lf] final class Compiler(\n     //       r = update token\n     //   in $endCommit(mustFail = false) r token\n     withEnv { _ =>\n-      val party = compile(partyE)\n-      val partyPos = nextPosition()\n-      val update = compile(updateE)\n-      val updatePos = nextPosition()\n-\n-      SELet(party, update) in\n-        withLabel(\n-          \"submit\",\n-          SEAbs(1) {\n-            val tokenPos = nextPosition()\n-            val beginCommit = SBSBeginCommit(optLoc)(svar(partyPos), svar(tokenPos))\n-            nextPosition()\n-            val result = SEApp(svar(updatePos), Array(svar(tokenPos)))\n-            val resultPos = nextPosition()\n-\n-            SELet(\n-              beginCommit,\n-              result\n-            ) in\n-              SBSEndCommit(mustFail = false)(svar(resultPos), svar(tokenPos))\n+      let(compile(partyE)) { partyPos =>\n+        let(compile(updateE)) { updatePos =>\n+          labeledFunction(\"submit\") { tokenPos =>\n+            let(SBSBeginCommit(optLoc)(svar(partyPos), svar(tokenPos))) { _ =>\n+              let(app(svar(updatePos), svar(tokenPos))) { resultPos =>\n+                SBSEndCommit(mustFail = false)(svar(resultPos), svar(tokenPos))"
  },
  {
    "id" : "752d3bce-f2c8-4200-981a-534a912d1e32",
    "prId" : 7493,
    "comments" : [
      {
        "id" : "2e29253d-cc9d-413d-8d2c-54c2e09c8b75",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "would `unaryFunction` be a clearer name?",
        "createdAt" : "2020-09-30T14:18:46Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fe322a71-0a48-46b9-a7ef-6f52b057f4ba",
        "parentId" : "2e29253d-cc9d-413d-8d2c-54c2e09c8b75",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2020-09-30T14:29:49Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : null,
    "diffHunk" : "@@ -211,6 +206,37 @@ private[lf] final class Compiler(\n       case None => expr\n     }\n \n+  @inline\n+  private[this] def app(f: SExpr, a: SExpr) = SEApp(f, Array(a))\n+\n+  @inline\n+  private[this] def let(bound: SExpr)(body: Position => SExpr) =\n+    SELet1General(bound, body(nextPosition()))\n+\n+  @inline\n+  private[this] def function(body: Position => SExpr): SExpr ="
  },
  {
    "id" : "7e0614c4-46f7-46a5-adce-5356b834aac9",
    "prId" : 7472,
    "comments" : [
      {
        "id" : "51b4417d-38dd-4e27-9292-c29113630b79",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This doesnâ€™t look quite right, this is still `exerciseByKey` but the description looks like `exercise`.",
        "createdAt" : "2020-09-24T06:36:34Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "412e71b8-5805-4bbf-aabe-a4b2fff842ad",
        "parentId" : "51b4417d-38dd-4e27-9292-c29113630b79",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2020-09-24T12:21:37Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : null,
    "diffHunk" : "@@ -1422,57 +1519,28 @@ private[lf] final class Compiler(\n         case None => SEValue.None\n         case Some(actors) => SEApp(SEBuiltin(SBSome), Array(actors))\n       }\n-      SEApp(\n-        SEVal(ChoiceDefRef(tmplId, choiceId)),\n-        Array(SEValue.bool(byKey), actors, contractId, argument))\n+      SEApp(SEVal(ChoiceDefRef(tmplId, choiceId)), Array(actors, contractId, argument))\n     }\n \n   private[this] def compileExerciseByKey(\n       tmplId: Identifier,\n       key: SExpr,\n       choiceId: ChoiceName,\n-      // actors are either the singleton set of submitter of an exercise command,\n-      // or the acting parties of an exercise node\n-      // of a transaction under reconstruction for validation\n+      // actors are only present when compiling old LF update expressions;\n+      // they are computed from the controllers in newer versions\n       optActors: Option[SExpr],\n       argument: SExpr,\n-  ): SExpr = {\n-    // Translates 'exerciseByKey Foo <key> <choiceName> <optActors> <argument>' into:\n-    // let key = <key>\n-    // let maintainers = keyMaintainers key\n-    // in \\token ->\n-    //    let coid = $fetchKey key maintainers token\n-    //        exerciseResult = exercise coid coid <optActors> <argument> token\n-    //    in exerciseResult\n-    val template = lookupTemplate(tmplId)\n+  ): SExpr =\n+    // Translates 'A does exercise cid Choice with <params>'"
  },
  {
    "id" : "2ad2cf0a-7ea4-421e-8474-6c04e6455958",
    "prId" : 7472,
    "comments" : [
      {
        "id" : "f6727fc8-bf60-4db5-ae0b-3af78bbf145c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n                  // contract =\r\n```",
        "createdAt" : "2020-09-24T06:39:46Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : null,
    "diffHunk" : "@@ -1503,115 +1570,129 @@ private[lf] final class Compiler(\n       )\n     }\n \n-  private[this] def compileLookupByKey(templateId: Identifier, key: SExpr): SExpr = {\n+  private[this] def compileLookupByKey(\n+      tmplId: Identifier,\n+      tmplKey: TemplateKey,\n+  ): (LookupByKeyDefRef, SExpr) =\n     // Translates 'lookupByKey Foo <key>' into:\n     // let keyWithMaintainers = {key: <key>, maintainers: <key maintainers> <key>}\n     // in \\token ->\n     //    let mbContractId = $lookupKey keyWithMaintainers\n     //        _ = $insertLookup Foo keyWithMaintainers\n     //    in mbContractId\n-    val template = lookupTemplate(templateId)\n-    withEnv { _ =>\n-      val templateKey = template.key.getOrElse(\n-        throw CompilationError(\n-          s\"Expecting to find key for template ${templateId}, but couldn't\",\n-        ),\n-      )\n-      SELet(encodeKeyWithMaintainers(key, templateKey)) in {\n-        env = env.incrPos // keyWithM\n-        withLabel(\n-          s\"lookupByKey @${templateId.qualifiedName}\",\n-          SEAbs(1) {\n-            env = env.incrPos // token\n-            SELet(\n-              SBULookupKey(templateId)(\n-                SEVar(2), // key with maintainers\n-                SEVar(1) // token\n-              ),\n-              SBUInsertLookupNode(templateId)(\n-                SEVar(3), // key with maintainers\n-                SEVar(1), // mb contract id\n-                SEVar(2) // token\n-              ),\n-            ) in SEVar(2) // mb contract id\n+    LookupByKeyDefRef(tmplId) ->\n+      validate(\n+        closureConvert(\n+          Map.empty,\n+          withEnv { _ =>\n+            withLabel(\n+              s\"lookupByKey @${tmplId.qualifiedName}\",\n+              SEAbs(2) {\n+                env = env.incrPos // key\n+                env = env.incrPos // token\n+                SELet(\n+                  // key with maintainer =\n+                  SBStructCon(keyWithMaintainersStruct)(\n+                    SEVar(2), // key\n+                    SEApp(compile(tmplKey.maintainers), Array(SEVar(2) /* key */ )),\n+                  ),\n+                  SBULookupKey(tmplId)(\n+                    SEVar(1), // key with maintainers\n+                    SEVar(2) // token\n+                  ),\n+                  SBUInsertLookupNode(tmplId)(\n+                    SEVar(2), // key with maintainers\n+                    SEVar(1), // mb contract id\n+                    SEVar(3) // token\n+                  ),\n+                ) in SEVar(2) // mb contract id\n+              }\n+            )\n           }\n-        )\n-      }\n-    }\n-  }\n+        ))\n \n   private[this] val fetchByKeyResultStruct: Struct[Int] =\n     Struct.assertFromSeq(List(contractIdFieldName, contractFieldName).zipWithIndex)\n \n   @inline\n-  private[this] def compileFetchByKey(templateId: TypeConName, key: SExpr) = {\n+  private[this] def compileFetchByKey(\n+      tmplId: TypeConName,\n+      tmpl: Template,\n+      tmplKey: TemplateKey,\n+  ): (FetchByKeyDefRef, SExpr) =\n     // Translates 'fetchByKey Foo <key>' into:\n     // let keyWithMaintainers = {key: <key>, maintainers: <key maintainers> <key>}\n     // in \\token ->\n     //    let coid = $fetchKey keyWithMaintainers token\n     //        contract = $fetch coid token\n     //        _ = $insertFetch coid <signatories> <observers> Some(keyWithMaintainers)\n     //    in { contractId: ContractId Foo, contract: Foo }\n-    val template = lookupTemplate(templateId)\n-    withEnv { _ =>\n-      val keyTemplate = template.key.getOrElse(\n-        throw CompilationError(\n-          s\"Expecting to find key for template ${templateId}, but couldn't\",\n-        ),\n-      )\n-      SELet(encodeKeyWithMaintainers(key, keyTemplate)) in {\n-        env = env.incrPos // key with maintainers\n-        withLabel(\n-          s\"fetchByKey @${templateId.qualifiedName}\",\n-          SEAbs(1) {\n-            env = env.incrPos // token\n-            env = env.addExprVar(template.param)\n-            // TODO should we evaluate this before we even construct\n-            // the update expression? this might be better for the user\n-            val signatories = compile(template.signatories)\n-            val observers = compile(template.observers)\n-            SELet(\n-              SBUFetchKey(templateId)(\n-                SEVar(2), // key with maintainers\n-                SEVar(1) // token\n-              ),\n-              SBUFetch(templateId)(\n-                SEVar(1), /* coid */\n-                SEVar(2) /* token */\n-              ),\n-              SBUInsertFetchNode(templateId, byKey = true)(\n-                SEVar(2), // coid\n-                signatories,\n-                observers,\n-                SEApp(SEBuiltin(SBSome), Array(SEVar(4))),\n-                SEVar(3) // token\n-              ),\n-            ) in SBStructCon(fetchByKeyResultStruct)(\n-              SEVar(3), // contract id\n-              SEVar(2) // contract\n+    FetchByKeyDefRef(tmplId) ->\n+      validate(\n+        closureConvert(\n+          Map.empty,\n+          withEnv { _ =>\n+            withLabel(\n+              s\"fetchByKey @${tmplId.qualifiedName}\",\n+              SEAbs(2) {\n+                env = env.incrPos // key\n+                env = env.incrPos // token\n+                env = env.addExprVar(tmpl.param)\n+                // TODO should we evaluate this before we even construct\n+                // the update expression? this might be better for the user\n+                val signatories = compile(tmpl.signatories)\n+                val observers = compile(tmpl.observers)\n+                SELet(\n+                  // key with maintainer =\n+                  SBStructCon(keyWithMaintainersStruct)(\n+                    SEVar(2), // key\n+                    SEApp(compile(tmplKey.maintainers), Array(SEVar(2) /* key */ )),\n+                  ),\n+                  // coid =\n+                  SBUFetchKey(tmplId)(\n+                    SEVar(1), // key with maintainers\n+                    SEVar(2) // token\n+                  ),\n+                  // contact ="
  },
  {
    "id" : "9bf7253e-45fd-496a-b621-7630f9282e92",
    "prId" : 7472,
    "comments" : [
      {
        "id" : "21c5d29f-65a9-4507-98a5-692b42310ea2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "There seems to be a lot of duplication between the definition of `ChoiceDefRef` and `ChoiceByKeyDefRef`. Iâ€™m not entirely clear why we need `ChoiceByKeyDefRef` at all. Whatâ€™s stopping us from compiling an `exerciseByKey` into `FetchByKeyDefRef` and `ChoiceDefRef` and removing `ChoiceByKeyDefRef`?",
        "createdAt" : "2020-09-24T06:45:16Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "00f157a5-0c20-4ce9-b0a5-a612b7720782",
        "parentId" : "21c5d29f-65a9-4507-98a5-692b42310ea2",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If it's possible to do what @cocreature described, I'd be in favor of that too.",
        "createdAt" : "2020-09-24T09:09:10Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "408198b5-78ec-42fc-a90b-43147690288a",
        "parentId" : "21c5d29f-65a9-4507-98a5-692b42310ea2",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "The issue is that the \"by cid\" operations (create, exercise, fetch) have to compute the contract key from the template argument (we need the key in the transaction even if the node was built by \"by cid\" ). On the other hand \"by key\" operation don't have to do, since it is given.\r\n\r\nI  do not see an easy way to factorize as @cocreature suggested without recompute the contract key for each \"by key\" operations.  Note that before my PR, contract key was recomputed for `ExerciseByKey`, but not for `FetchByKey`.\r\n\r\nWe can of course, make a bit of factorization in the Scala code (I would let that for the following PR), but I think it is tricky to do it at the LF level.",
        "createdAt" : "2020-09-24T12:13:51Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cd011451-6fad-49d9-9e08-5fdd977fd378",
        "parentId" : "21c5d29f-65a9-4507-98a5-692b42310ea2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Makes sense, Iâ€™m fine with leaving it for a separate PR.",
        "createdAt" : "2020-09-24T13:27:52Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : 210,
    "diffHunk" : "@@ -878,80 +889,174 @@ private[lf] final class Compiler(\n   private[this] def translateKeyWithMaintainers(tmplKey: TemplateKey): SExpr =\n     encodeKeyWithMaintainers(compile(tmplKey.body), tmplKey)\n \n-  /** Compile a choice into a top-level function for exercising that choice */\n-  @inline\n   private[this] def compileChoice(\n       tmplId: TypeConName,\n       tmpl: Template,\n       cname: ChoiceName,\n       choice: TemplateChoice,\n-  ): SExpr =\n+  ): (ChoiceDefRef, SExpr) =\n     // Compiles a choice into:\n-    // SomeTemplate$SomeChoice = \\<byKey flag> <actors> <cid> <choice arg> <token> ->\n+    // SomeTemplate$SomeChoice = \\<actors> <cid> <choiceArg> <token> ->\n     //   let targ = fetch <cid>\n-    //       _ = $beginExercise[tmplId, chId] <choice arg> <cid> <actors> <byKey flag> sigs obs ctrls mbKey <token>\n+    //       _ = $beginExercise[tmplId, chId] <choiceArg> <cid> <actors> <byKey flag> sigs obs ctrls mbKey <token>\n     //       result = <updateE>\n     //       _ = $endExercise[tmplId]\n     //   in result\n-    validate(\n-      closureConvert(\n-        Map.empty,\n-        withEnv { _ =>\n-          env = env.incrPos // <byKey flag>\n-          env = env.incrPos // <actors>\n-          val selfBinderPos = env.position\n-          env = env.incrPos // <cid>\n-          val choiceArgumentPos = env.position\n-          env = env.incrPos // <choice argument>\n-          env = env.incrPos // <token>\n-\n-          // <template argument>\n-          env = env.addExprVar(tmpl.param)\n-\n-          val signatories = compile(tmpl.signatories)\n-          val observers = compile(tmpl.observers)\n-          // now allow access to the choice argument\n-          env = env.addExprVar(choice.argBinder._1, choiceArgumentPos)\n-          val controllers = compile(choice.controllers)\n-          val mbKey: SExpr = tmpl.key match {\n-            case None => SEValue.None\n-            case Some(k) => SEApp(SEBuiltin(SBSome), Array(translateKeyWithMaintainers(k)))\n-          }\n-          env = env.incrPos // beginExercise's ()\n-\n-          // allow access to the self contract id\n-          env = env.addExprVar(choice.selfBinder, selfBinderPos)\n-          val update = compile(choice.update)\n-          withLabel(\n-            s\"exercise @${tmplId.qualifiedName} ${cname}\",\n-            SEAbs(5) {\n-              SELet(\n-                // stack: <byKey flag> <actors> <cid> <choice arg> <token>\n-                SBUFetch(tmplId)(SEVar(3) /* <cid> */, SEVar(1) /* <token> */ ),\n-                // stack: <byKey flag> <actors> <cid> <choice arg> <token> <template arg>\n-                SBUBeginExercise(tmplId, choice.name, choice.consuming)(\n-                  SEVar(3), // <choice arg>\n-                  SEVar(4), // <cid>\n-                  SEVar(5), // <actors>\n-                  SEVar(6), // <byKey flag>\n-                  signatories,\n-                  observers,\n-                  controllers,\n-                  mbKey,\n-                  SEVar(2),\n-                ),\n-                // stack: <byKey flag> <actors> <cid> <choice arg> <token> <template arg> ()\n-                SEApp(update, Array(SEVar(3))),\n-                // stack: <byKey flag> <actors> <cid> <choice arg> <token> <template arg> () <ret value>\n-                SBUEndExercise(tmplId)(SEVar(4), SEVar(1)),\n-              ) in\n-                // stack: <byKey flag> <actors> <cid> <choice arg> <token> <template arg> () <ret value> ()\n-                SEVar(2)\n+    ChoiceDefRef(tmplId, cname) ->\n+      validate(\n+        closureConvert(\n+          Map.empty,\n+          withEnv { _ =>\n+            env = env.incrPos /* <actors> */\n+            val selfBinderPos = env.position\n+            env = env.incrPos /* <cid> */\n+            val choiceArgumentPos = env.position\n+            env = env.incrPos // <choice argument>\n+            env = env.incrPos /* <token> */\n+            // <template argument>\n+            env = env.addExprVar(tmpl.param)\n+            val signatories = compile(tmpl.signatories)\n+            val observers = compile(tmpl.observers)\n+            // now allow access to the choice argument\n+            env = env.addExprVar(choice.argBinder._1, choiceArgumentPos)\n+            val controllers = compile(choice.controllers)\n+            val mbKey: SExpr = tmpl.key match {\n+              case None => SEValue.None\n+              case Some(k) => SEApp(SEBuiltin(SBSome), Array(translateKeyWithMaintainers(k)))\n             }\n-          )\n-        },\n-      ),\n-    )\n+            env = env.incrPos // beginExercise's ()\n+            // allow access to the self contract id\n+            env = env.addExprVar(choice.selfBinder, selfBinderPos)\n+            val update = compile(choice.update)\n+\n+            withLabel(\n+              s\"exercise @${tmplId.qualifiedName} ${cname}\",\n+              SEAbs(4) {\n+                SELet(\n+                  // stack: <actors> <cid> <choiceArg> <token>\n+                  // <tmplArg> =\n+                  SBUFetch(tmplId)(SEVar(3) /* <cid> */, SEVar(1) /* <token> */ ),\n+                  // stack: <actors> <cid> <choiceArg> <token> <tmplArg>\n+                  // _ =\n+                  SBUBeginExercise(tmplId, choice.name, choice.consuming, byKey = false)(\n+                    SEVar(3), /* <choiceArg> */\n+                    SEVar(4), /* <cid> */\n+                    SEVar(5), /* <actors> */\n+                    signatories,\n+                    observers,\n+                    controllers,\n+                    mbKey,\n+                    SEVar(2) /* <token> */\n+                  ),\n+                  // stack: <actors> <cid> <choiceArg> <token> <tmplArg> ()\n+                  // <ret value> =\n+                  SEApp(update, Array(SEVar(3) /* <token> */ )),\n+                  // stack: <actors> <cid> <choiceArg> <token> <tmplArg> () <ret value>\n+                  // _ =\n+                  SBUEndExercise(tmplId)(\n+                    SEVar(4), /* <token> */\n+                    SEVar(1) /* <retValue> */\n+                  )\n+                ) in\n+                  // stack: <actors> <cid> <choiceArg> <token> <tmplArg> () <ret value> ()\n+                  SEVar(2) /* <retValue> */\n+              }\n+            )\n+          },\n+        ),\n+      )\n+\n+  /** Compile a choice into a top-level function for exercising that choice */\n+  private[this] def compileChoiceByKey("
  },
  {
    "id" : "383f3c63-a413-4d2d-9349-5cddae98b99b",
    "prId" : 7472,
    "comments" : [
      {
        "id" : "6bc13a7f-4155-418d-b7dd-6c5bd9e921ff",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    //       _ = $beginExercise[tmplId, chId, consuming, byKey = false] <choiceArg> <cid> <actors> sigs obs ctrls mbKey <token>\r\n```",
        "createdAt" : "2020-09-24T10:07:39Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : 83,
    "diffHunk" : "@@ -878,80 +889,174 @@ private[lf] final class Compiler(\n   private[this] def translateKeyWithMaintainers(tmplKey: TemplateKey): SExpr =\n     encodeKeyWithMaintainers(compile(tmplKey.body), tmplKey)\n \n-  /** Compile a choice into a top-level function for exercising that choice */\n-  @inline\n   private[this] def compileChoice(\n       tmplId: TypeConName,\n       tmpl: Template,\n       cname: ChoiceName,\n       choice: TemplateChoice,\n-  ): SExpr =\n+  ): (ChoiceDefRef, SExpr) =\n     // Compiles a choice into:\n-    // SomeTemplate$SomeChoice = \\<byKey flag> <actors> <cid> <choice arg> <token> ->\n+    // SomeTemplate$SomeChoice = \\<actors> <cid> <choiceArg> <token> ->\n     //   let targ = fetch <cid>\n-    //       _ = $beginExercise[tmplId, chId] <choice arg> <cid> <actors> <byKey flag> sigs obs ctrls mbKey <token>\n+    //       _ = $beginExercise[tmplId, chId] <choiceArg> <cid> <actors> <byKey flag> sigs obs ctrls mbKey <token>"
  },
  {
    "id" : "c5faa48d-3a57-4e8e-baad-0824f27cfa4d",
    "prId" : 7472,
    "comments" : [
      {
        "id" : "6c8f739f-8f9b-4d3c-8dd1-464ad0caa73b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does this comment make any sense? There's nothing we could evaluate before we fetched the contract from the ledger, which needs to happen in the `Update` monad, because we need the payload of the contract for all the evaluations. Or am I misunderstanding something?",
        "createdAt" : "2020-09-24T10:22:24Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "146e53bd-28d5-4e9a-8950-468ff680ea43",
        "parentId" : "6c8f739f-8f9b-4d3c-8dd1-464ad0caa73b",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped. ",
        "createdAt" : "2020-09-24T12:50:15Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "009b6cd5-65df-4c0b-9e47-16d119a0a783",
        "parentId" : "6c8f739f-8f9b-4d3c-8dd1-464ad0caa73b",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Merci.",
        "createdAt" : "2020-09-24T13:44:08Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : null,
    "diffHunk" : "@@ -1503,115 +1570,129 @@ private[lf] final class Compiler(\n       )\n     }\n \n-  private[this] def compileLookupByKey(templateId: Identifier, key: SExpr): SExpr = {\n+  private[this] def compileLookupByKey(\n+      tmplId: Identifier,\n+      tmplKey: TemplateKey,\n+  ): (LookupByKeyDefRef, SExpr) =\n     // Translates 'lookupByKey Foo <key>' into:\n     // let keyWithMaintainers = {key: <key>, maintainers: <key maintainers> <key>}\n     // in \\token ->\n     //    let mbContractId = $lookupKey keyWithMaintainers\n     //        _ = $insertLookup Foo keyWithMaintainers\n     //    in mbContractId\n-    val template = lookupTemplate(templateId)\n-    withEnv { _ =>\n-      val templateKey = template.key.getOrElse(\n-        throw CompilationError(\n-          s\"Expecting to find key for template ${templateId}, but couldn't\",\n-        ),\n-      )\n-      SELet(encodeKeyWithMaintainers(key, templateKey)) in {\n-        env = env.incrPos // keyWithM\n-        withLabel(\n-          s\"lookupByKey @${templateId.qualifiedName}\",\n-          SEAbs(1) {\n-            env = env.incrPos // token\n-            SELet(\n-              SBULookupKey(templateId)(\n-                SEVar(2), // key with maintainers\n-                SEVar(1) // token\n-              ),\n-              SBUInsertLookupNode(templateId)(\n-                SEVar(3), // key with maintainers\n-                SEVar(1), // mb contract id\n-                SEVar(2) // token\n-              ),\n-            ) in SEVar(2) // mb contract id\n+    LookupByKeyDefRef(tmplId) ->\n+      validate(\n+        closureConvert(\n+          Map.empty,\n+          withEnv { _ =>\n+            withLabel(\n+              s\"lookupByKey @${tmplId.qualifiedName}\",\n+              SEAbs(2) {\n+                env = env.incrPos // key\n+                env = env.incrPos // token\n+                SELet(\n+                  // key with maintainer =\n+                  SBStructCon(keyWithMaintainersStruct)(\n+                    SEVar(2), // key\n+                    SEApp(compile(tmplKey.maintainers), Array(SEVar(2) /* key */ )),\n+                  ),\n+                  SBULookupKey(tmplId)(\n+                    SEVar(1), // key with maintainers\n+                    SEVar(2) // token\n+                  ),\n+                  SBUInsertLookupNode(tmplId)(\n+                    SEVar(2), // key with maintainers\n+                    SEVar(1), // mb contract id\n+                    SEVar(3) // token\n+                  ),\n+                ) in SEVar(2) // mb contract id\n+              }\n+            )\n           }\n-        )\n-      }\n-    }\n-  }\n+        ))\n \n   private[this] val fetchByKeyResultStruct: Struct[Int] =\n     Struct.assertFromSeq(List(contractIdFieldName, contractFieldName).zipWithIndex)\n \n   @inline\n-  private[this] def compileFetchByKey(templateId: TypeConName, key: SExpr) = {\n+  private[this] def compileFetchByKey(\n+      tmplId: TypeConName,\n+      tmpl: Template,\n+      tmplKey: TemplateKey,\n+  ): (FetchByKeyDefRef, SExpr) =\n     // Translates 'fetchByKey Foo <key>' into:\n     // let keyWithMaintainers = {key: <key>, maintainers: <key maintainers> <key>}\n     // in \\token ->\n     //    let coid = $fetchKey keyWithMaintainers token\n     //        contract = $fetch coid token\n     //        _ = $insertFetch coid <signatories> <observers> Some(keyWithMaintainers)\n     //    in { contractId: ContractId Foo, contract: Foo }\n-    val template = lookupTemplate(templateId)\n-    withEnv { _ =>\n-      val keyTemplate = template.key.getOrElse(\n-        throw CompilationError(\n-          s\"Expecting to find key for template ${templateId}, but couldn't\",\n-        ),\n-      )\n-      SELet(encodeKeyWithMaintainers(key, keyTemplate)) in {\n-        env = env.incrPos // key with maintainers\n-        withLabel(\n-          s\"fetchByKey @${templateId.qualifiedName}\",\n-          SEAbs(1) {\n-            env = env.incrPos // token\n-            env = env.addExprVar(template.param)\n-            // TODO should we evaluate this before we even construct\n-            // the update expression? this might be better for the user\n-            val signatories = compile(template.signatories)\n-            val observers = compile(template.observers)\n-            SELet(\n-              SBUFetchKey(templateId)(\n-                SEVar(2), // key with maintainers\n-                SEVar(1) // token\n-              ),\n-              SBUFetch(templateId)(\n-                SEVar(1), /* coid */\n-                SEVar(2) /* token */\n-              ),\n-              SBUInsertFetchNode(templateId, byKey = true)(\n-                SEVar(2), // coid\n-                signatories,\n-                observers,\n-                SEApp(SEBuiltin(SBSome), Array(SEVar(4))),\n-                SEVar(3) // token\n-              ),\n-            ) in SBStructCon(fetchByKeyResultStruct)(\n-              SEVar(3), // contract id\n-              SEVar(2) // contract\n+    FetchByKeyDefRef(tmplId) ->\n+      validate(\n+        closureConvert(\n+          Map.empty,\n+          withEnv { _ =>\n+            withLabel(\n+              s\"fetchByKey @${tmplId.qualifiedName}\",\n+              SEAbs(2) {\n+                env = env.incrPos // key\n+                env = env.incrPos // token\n+                env = env.addExprVar(tmpl.param)\n+                // TODO should we evaluate this before we even construct\n+                // the update expression? this might be better for the user"
  },
  {
    "id" : "be125cfb-6bb9-4524-8825-f7bc603c372d",
    "prId" : 7319,
    "comments" : [
      {
        "id" : "1704fed8-cbd7-4f45-b217-c31290bd4723",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why do we need to zip with the index and then convert into an indexed seq? That looks like double indexing to me, but I guess my Scala is just not good enough...",
        "createdAt" : "2020-09-04T10:53:27Z",
        "updatedAt" : "2020-09-04T16:34:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a0762d9c-907f-4926-9dea-c2a27899aa56",
        "parentId" : "1704fed8-cbd7-4f45-b217-c31290bd4723",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I changed to `.toSeq`, I tried to be clever but it is just useless.\r\n\r\nfor your information:\r\n> Indexed sequences support constant-time or near constant-time element access\r\n",
        "createdAt" : "2020-09-04T12:02:20Z",
        "updatedAt" : "2020-09-04T16:34:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abf995d1e965f73aac6422c0d37ee6362850f920",
    "line" : null,
    "diffHunk" : "@@ -445,8 +448,10 @@ private[lf] final case class Compiler(\n       }\n \n       case EStructCon(fields) =>\n+        val fieldsInputOrder =\n+          Struct.assertFromSeq(fields.iterator.map(_._1).zipWithIndex.toIndexedSeq)"
  },
  {
    "id" : "74abc965-8243-4d16-919e-e9d6125a7599",
    "prId" : 7319,
    "comments" : [
      {
        "id" : "67ce361d-8d47-4330-bdda-627204dd3b1f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n  private[this] val keyWithMaintainersStruct: Struct[Int] =\r\n```\r\nto be in line with `fetchByKeyResultStruct`.",
        "createdAt" : "2020-09-04T10:56:01Z",
        "updatedAt" : "2020-09-04T16:34:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab4152bb-0c2f-4e9e-826d-4b102216f686",
        "parentId" : "67ce361d-8d47-4330-bdda-627204dd3b1f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-09-04T12:02:59Z",
        "updatedAt" : "2020-09-04T16:34:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abf995d1e965f73aac6422c0d37ee6362850f920",
    "line" : null,
    "diffHunk" : "@@ -858,9 +857,12 @@ private[lf] final case class Compiler(\n     }\n   }\n \n+  private[this] val keyWithMaintainersFieldsInputOrder: Struct[Int] ="
  },
  {
    "id" : "4b9df134-9d87-4782-8624-098b3ca4bf8c",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "c001407d-bbff-4075-a688-06604f247074",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n          args.foldLeft(free)((free, arg) =>  go(arg, bound, free))\r\n```",
        "createdAt" : "2020-06-30T14:29:11Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] =\n       expr match {\n         case SEVar(i) =>\n-          if (i > bound)\n-            free += i - bound /* adjust to caller's environment */\n-        case _: SEVal => ()\n-        case _: SEBuiltin => ()\n-        case _: SEValue => ()\n-        case _: SEBuiltinRecursiveDefinition => ()\n+          if (i > bound) Set(i - bound) else Set() /* adjust to caller's environment */\n+        case _: SEVal => Set()\n+        case _: SEBuiltin => Set()\n+        case _: SEValue => Set()\n+        case _: SEBuiltinRecursiveDefinition => Set()\n         case SELocation(_, body) =>\n-          go(body)\n+          go(body, bound)\n         case SEAppGeneral(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppAtomicFun(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppSaturatedBuiltinFun(_, args) =>\n-          args.foreach(go)\n+          args.map(go(_, bound)).reduce(_ ++ _)"
  },
  {
    "id" : "5b6cdeb7-adad-49a5-af43-d5914d9a8471",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "426b0722-72d8-43bc-8ef9-638d11e71970",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    def go(expr: SExpr, bound: Int, free: Set[Int]): Set[Int] =\r\n```",
        "createdAt" : "2020-06-30T14:29:33Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8309e1e9-82af-41aa-8400-aac6f4669160",
        "parentId" : "426b0722-72d8-43bc-8ef9-638d11e71970",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "It looks like if you accept all @remyhaemmerle-da's changes, you can add `@tailrec` to this function too.",
        "createdAt" : "2020-06-30T14:41:32Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "92cde981-d29a-4936-9e6b-c7b9b8bdec5d",
        "parentId" : "426b0722-72d8-43bc-8ef9-638d11e71970",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Unfortunately you can't because we are traversing a tree.",
        "createdAt" : "2020-06-30T14:48:04Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4a70440d-11a5-48b0-b849-5aa58f129e21",
        "parentId" : "426b0722-72d8-43bc-8ef9-638d11e71970",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "It's a tree traversal so I don't think that will be possible. `args.foldLeft(free)((free, arg) =>  go(arg, bound, free))` for example is not a (recursive) tail call.",
        "createdAt" : "2020-06-30T15:01:08Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eda67f07-9cfb-45f1-8292-7deca231e964",
        "parentId" : "426b0722-72d8-43bc-8ef9-638d11e71970",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Missed that; thanks for explaining.",
        "createdAt" : "2020-06-30T15:02:02Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] ="
  },
  {
    "id" : "5f22e7e1-87d8-425e-a053-b5308239b4a5",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "dc11c11b-113d-4e4b-ab8e-9f0020e6fe1a",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n          if (i > bound) (free + (i - bound)) else free /* adjust to caller's environment */\r\n```",
        "createdAt" : "2020-06-30T14:30:06Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] =\n       expr match {\n         case SEVar(i) =>\n-          if (i > bound)\n-            free += i - bound /* adjust to caller's environment */\n-        case _: SEVal => ()\n-        case _: SEBuiltin => ()\n-        case _: SEValue => ()\n-        case _: SEBuiltinRecursiveDefinition => ()\n+          if (i > bound) Set(i - bound) else Set() /* adjust to caller's environment */"
  },
  {
    "id" : "207bd823-7e89-4ee7-8245-3d66bc1295af",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "f3efdb79-8544-4d06-b2b4-9e1b807bda46",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n        case _: SEVal => free\r\n```",
        "createdAt" : "2020-06-30T14:30:37Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] =\n       expr match {\n         case SEVar(i) =>\n-          if (i > bound)\n-            free += i - bound /* adjust to caller's environment */\n-        case _: SEVal => ()\n-        case _: SEBuiltin => ()\n-        case _: SEValue => ()\n-        case _: SEBuiltinRecursiveDefinition => ()\n+          if (i > bound) Set(i - bound) else Set() /* adjust to caller's environment */\n+        case _: SEVal => Set()"
  },
  {
    "id" : "bc4ff0a9-f829-4337-95c4-aae00616d6a5",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "ecafe98a-df44-44d3-84b7-327e09cd37fc",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n            alts.foldLeft(go(scrut, bound, free)) {\r\n            case (free, SCaseAlt(pat, body)) => go(body, bound + patternNArgs(pat), free)\r\n          }\r\n```",
        "createdAt" : "2020-06-30T14:32:17Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] =\n       expr match {\n         case SEVar(i) =>\n-          if (i > bound)\n-            free += i - bound /* adjust to caller's environment */\n-        case _: SEVal => ()\n-        case _: SEBuiltin => ()\n-        case _: SEValue => ()\n-        case _: SEBuiltinRecursiveDefinition => ()\n+          if (i > bound) Set(i - bound) else Set() /* adjust to caller's environment */\n+        case _: SEVal => Set()\n+        case _: SEBuiltin => Set()\n+        case _: SEValue => Set()\n+        case _: SEBuiltinRecursiveDefinition => Set()\n         case SELocation(_, body) =>\n-          go(body)\n+          go(body, bound)\n         case SEAppGeneral(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppAtomicFun(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppSaturatedBuiltinFun(_, args) =>\n-          args.foreach(go)\n+          args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAbs(n, body) =>\n-          bound += n\n-          go(body)\n-          bound -= n\n+          go(body, bound + n)\n         case x: SELoc =>\n           throw CompilationError(s\"freeVars: unexpected SELoc: $x\")\n         case x: SEMakeClo =>\n           throw CompilationError(s\"freeVars: unexpected SEMakeClo: $x\")\n         case SECase(scrut, alts) =>\n-          go(scrut)\n-          alts.foreach {\n-            case SCaseAlt(pat, body) =>\n-              val n = patternNArgs(pat)\n-              bound += n; go(body); bound -= n\n-          }\n+          go(scrut, bound) ++ alts\n+            .map { case SCaseAlt(pat, body) => go(body, bound + patternNArgs(pat)) }\n+            .reduce(_ ++ _)"
  },
  {
    "id" : "38ce8969-494b-4f69-9ec5-3ba1a1279690",
    "prId" : 6542,
    "comments" : [
      {
        "id" : "cd98d0e8-41df-497b-9741-e93a7228f5ee",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    go(expr, initiallyBound, Set.empty)\r\n```",
        "createdAt" : "2020-06-30T14:32:30Z",
        "updatedAt" : "2020-07-01T00:38:30Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "65fd27037b4cd2ae6f9b5449c99de0378a1f0981",
    "line" : null,
    "diffHunk" : "@@ -1125,67 +1125,50 @@ private[lf] final case class Compiler(\n     * The returned free variables are de bruijn indices\n     * adjusted to the stack of the caller. */\n   def freeVars(expr: SExpr, initiallyBound: Int): Set[Int] = {\n-    var bound = initiallyBound\n-    var free = Set.empty[Int]\n-\n-    def go(expr: SExpr): Unit =\n+    def go(expr: SExpr, bound: Int): Set[Int] =\n       expr match {\n         case SEVar(i) =>\n-          if (i > bound)\n-            free += i - bound /* adjust to caller's environment */\n-        case _: SEVal => ()\n-        case _: SEBuiltin => ()\n-        case _: SEValue => ()\n-        case _: SEBuiltinRecursiveDefinition => ()\n+          if (i > bound) Set(i - bound) else Set() /* adjust to caller's environment */\n+        case _: SEVal => Set()\n+        case _: SEBuiltin => Set()\n+        case _: SEValue => Set()\n+        case _: SEBuiltinRecursiveDefinition => Set()\n         case SELocation(_, body) =>\n-          go(body)\n+          go(body, bound)\n         case SEAppGeneral(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppAtomicFun(fun, args) =>\n-          go(fun)\n-          args.foreach(go)\n+          go(fun, bound) ++ args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAppSaturatedBuiltinFun(_, args) =>\n-          args.foreach(go)\n+          args.map(go(_, bound)).reduce(_ ++ _)\n         case SEAbs(n, body) =>\n-          bound += n\n-          go(body)\n-          bound -= n\n+          go(body, bound + n)\n         case x: SELoc =>\n           throw CompilationError(s\"freeVars: unexpected SELoc: $x\")\n         case x: SEMakeClo =>\n           throw CompilationError(s\"freeVars: unexpected SEMakeClo: $x\")\n         case SECase(scrut, alts) =>\n-          go(scrut)\n-          alts.foreach {\n-            case SCaseAlt(pat, body) =>\n-              val n = patternNArgs(pat)\n-              bound += n; go(body); bound -= n\n-          }\n+          go(scrut, bound) ++ alts\n+            .map { case SCaseAlt(pat, body) => go(body, bound + patternNArgs(pat)) }\n+            .reduce(_ ++ _)\n         case SELet(bounds, body) =>\n-          bounds.foreach { e =>\n-            go(e)\n-            bound += 1\n-          }\n-          go(body)\n-          bound -= bounds.size\n+          (bounds ++ Seq(body)).zipWithIndex\n+            .map { case (expr, idx) => go(expr, bound + idx) }\n+            .reduce(_ ++ _)\n         case SECatch(body, handler, fin) =>\n-          go(body)\n-          go(handler)\n-          go(fin)\n+          go(body, bound) ++ go(handler, bound) ++ go(fin, bound)\n         case SELabelClosure(_, expr) =>\n-          go(expr)\n+          go(expr, bound)\n         case x: SEWronglyTypeContractId =>\n           throw CompilationError(s\"unexpected SEWronglyTypeContractId: $x\")\n         case x: SEImportValue =>\n           throw CompilationError(s\"unexpected SEImportValue: $x\")\n       }\n-    go(expr)\n-    free\n+    go(expr, initiallyBound)"
  },
  {
    "id" : "a9b5b062-2161-4464-bf1d-4c3fc214d124",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "45519318-bb73-4c4e-94c1-21d9f6499a69",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n  // (1) closure conversion\r\n```",
        "createdAt" : "2020-06-22T08:59:03Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c7981a90-4ead-4174-b615-49c8b524c979",
        "parentId" : "45519318-bb73-4c4e-94c1-21d9f6499a69",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-06-25T10:28:43Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : null,
    "diffHunk" : "@@ -169,17 +172,55 @@ private[lf] final case class Compiler(\n   @throws[PackageNotFound]\n   @throws[CompilationError]\n   def unsafeCompile(cmds: ImmArray[Command]): SExpr =\n-    validate(closureConvert(Map.empty, translateCommands(cmds)))\n+    validate(compilationPipeline(None, translateCommands(cmds)))\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeCompile(expr: Expr): SExpr =\n-    validate(closureConvert(Map.empty, translate(expr)))\n+  def unsafeCompile(expr: Expr, who: Option[Identifier] = None): SExpr = {\n+    validate(compilationPipeline(who, translate(expr)))\n+  }\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n   def unsafeClosureConvert(sexpr: SExpr): SExpr =\n-    validate(closureConvert(Map.empty, sexpr))\n+    validate(compilationPipeline(None, sexpr))\n+\n+  // Run the compilation pipeline phases:\n+  // (2) closure conversion"
  },
  {
    "id" : "650217e7-e8c9-45e9-94c3-afd8feb041f9",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "afbd0864-27c7-445c-ab97-ede00e18592d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The function name does not match its intent anymore.",
        "createdAt" : "2020-06-26T10:40:10Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab33a7b2-6d54-482d-9adf-13b3cb3189dc",
        "parentId" : "afbd0864-27c7-445c-ab97-ede00e18592d",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "fixed",
        "createdAt" : "2020-06-30T14:56:50Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : null,
    "diffHunk" : "@@ -170,29 +173,67 @@ private[lf] final case class Compiler(\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeCompile(cmds: ImmArray[Command]): SExpr =\n-    validate(closureConvert(Map.empty, translateCommands(cmds)))\n+  def unsafeCompile(cmds: ImmArray[Command]): AExpr =\n+    validate(compilationPipeline(None, translateCommands(cmds)))\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeCompile(expr: Expr): SExpr =\n-    validate(closureConvert(Map.empty, translate(expr)))\n+  def unsafeCompile(expr: Expr, who: Option[Identifier] = None): AExpr = {\n+    validate(compilationPipeline(who, translate(expr)))\n+  }\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeClosureConvert(sexpr: SExpr): SExpr =\n-    validate(closureConvert(Map.empty, sexpr))\n+  def unsafeClosureConvert(sexpr: SExpr): AExpr ="
  },
  {
    "id" : "01c18da5-ee6d-4e97-80ce-1e63d810299f",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "a21dbf72-fe87-47fe-b4af-aed5a77b8337",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This `who` parameter and the `tagOpt` function below look like debugging code on their way into prod. Let's please clean this up.",
        "createdAt" : "2020-06-26T10:43:18Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ca81eedf-d9f3-45f2-92e7-8069332937bb",
        "parentId" : "a21dbf72-fe87-47fe-b4af-aed5a77b8337",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "removed the dev/debug code and the `who` parameter.",
        "createdAt" : "2020-06-30T14:57:13Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : null,
    "diffHunk" : "@@ -170,29 +173,67 @@ private[lf] final case class Compiler(\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeCompile(cmds: ImmArray[Command]): SExpr =\n-    validate(closureConvert(Map.empty, translateCommands(cmds)))\n+  def unsafeCompile(cmds: ImmArray[Command]): AExpr =\n+    validate(compilationPipeline(None, translateCommands(cmds)))\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeCompile(expr: Expr): SExpr =\n-    validate(closureConvert(Map.empty, translate(expr)))\n+  def unsafeCompile(expr: Expr, who: Option[Identifier] = None): AExpr = {\n+    validate(compilationPipeline(who, translate(expr)))\n+  }\n \n   @throws[PackageNotFound]\n   @throws[CompilationError]\n-  def unsafeClosureConvert(sexpr: SExpr): SExpr =\n-    validate(closureConvert(Map.empty, sexpr))\n+  def unsafeClosureConvert(sexpr: SExpr): AExpr =\n+    validate(compilationPipeline(None, sexpr))\n+\n+  // Run the compilation pipeline phases:\n+  // (1) closure conversion\n+  // (2) transform to ANF\n+  def compilationPipeline(who: Option[Identifier], sexpr: SExpr): AExpr = {"
  },
  {
    "id" : "3ff9e552-98aa-4ff5-b8e4-b7e4b1de3daa",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "0d64460d-c578-4b52-8914-bbea9dc2806a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why change this?",
        "createdAt" : "2020-06-26T10:45:58Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "805c603c-56f6-41fb-9fa5-738132baf3df",
        "parentId" : "0d64460d-c578-4b52-8914-bbea9dc2806a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I changed it back",
        "createdAt" : "2020-06-30T14:58:03Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : null,
    "diffHunk" : "@@ -915,8 +956,8 @@ private[lf] final case class Compiler(\n                 SEVar(2)\n             }\n           )\n-        },\n-      ),\n+        }\n+      )"
  },
  {
    "id" : "8e7eb301-7dc4-4812-ad8c-77db7deecea1",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "97d5f4d6-ae29-4541-8bf7-da2bde26b5b2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n\r\n```",
        "createdAt" : "2020-06-26T10:49:38Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d20a354-7fb2-4375-990a-06a1764f5148",
        "parentId" : "97d5f4d6-ae29-4541-8bf7-da2bde26b5b2",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "gone",
        "createdAt" : "2020-06-30T14:58:10Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : null,
    "diffHunk" : "@@ -1211,7 +1243,7 @@ private[lf] final case class Compiler(\n     }\n \n     def goBody(maxS: Int, maxA: Int, maxF: Int): SExpr => Unit = {\n-\n+      //println(s\"goBody, maxS=$maxS\")"
  },
  {
    "id" : "92a963a8-4778-4ebe-a731-6e8177111070",
    "prId" : 6440,
    "comments" : [
      {
        "id" : "5b8256e2-e20a-481c-b0fd-5168e846aca5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "IIRC, this function was already occasionally hitting the limits of stack usage before this change. Linearizing the code using `ELet1*` makes the situation worse. I suggest we rewrite this function using some technique that does not blow up the stack _before_ we merge this change and rebase this change on top of the other one.\r\ncc @remyhaemmerle-da",
        "createdAt" : "2020-06-26T10:57:30Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "df8d46f1-3580-4d9e-b657-0386fd5a8df7",
        "parentId" : "5b8256e2-e20a-481c-b0fd-5168e846aca5",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "The validate function is fixed now.",
        "createdAt" : "2020-06-30T14:58:39Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "76f8bd9c-dc98-4a39-b0a6-b475ac6f5966",
        "parentId" : "5b8256e2-e20a-481c-b0fd-5168e846aca5",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Thank you.",
        "createdAt" : "2020-06-30T16:43:42Z",
        "updatedAt" : "2020-06-30T16:46:27Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : 177,
    "diffHunk" : "@@ -1187,7 +1219,7 @@ private[lf] final case class Compiler(\n   /** Validate variable references in a speedy expression */\n   // valiate that we correctly captured all free-variables, and so reference to them is\n   // via the surrounding closure, instead of just finding them higher up on the stack\n-  def validate(expr0: SExpr): SExpr = {\n+  def validate(anf0: AExpr): AExpr = {"
  },
  {
    "id" : "70ae2da1-bf0a-4b99-8ee5-3a59f9b90a44",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "0c25efd3-e8d5-44c5-80af-88b550c8231e",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    val m2 = (1 to n).map(i => (i, SELocS(i)))\r\n```\r\n",
        "createdAt" : "2020-05-18T15:54:38Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e9c75a70-a91e-461b-a747-3c30b48d32bb",
        "parentId" : "0c25efd3-e8d5-44c5-80af-88b550c8231e",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-05-19T12:58:05Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -1009,6 +1017,25 @@ private[lf] final case class Compiler(packages: PackageId PartialFunction Packag\n     }\n   }\n \n+  // Modify/extend `remaps` to reflect when new values are pushed on the stack. For SELet and SECase bindings\n+  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {\n+\n+    // We must update both the keys of the map (the relative-indexes from the original SEVar)\n+    // And also any values in the map which are stack located (SELocS), which are also indexed relatively\n+    val m1 = (remaps.toList.map { case (k, loc) => (n + k, shiftLoc(loc, n)) }.toMap)\n+\n+    // And create mappings for the `n` new stack items\n+    val m2 = (1 to n).map(i => (i, SELocS(i))).toMap"
  },
  {
    "id" : "77ba8185-42f7-4c75-9904-ae29a96297bc",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "af6eaacb-8960-4fe1-b0c2-c77380af8f94",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    case SELocA(_) | SELocF(_) => loc\r\n```",
        "createdAt" : "2020-05-18T15:55:29Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dc7ce0cd-b43f-424c-9a5a-21158357430c",
        "parentId" : "af6eaacb-8960-4fe1-b0c2-c77380af8f94",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@remyhaemmerle-da Do you know about multiline suggestions? They would allow you to have this suggestion and the next one as a single suggestion.",
        "createdAt" : "2020-05-19T17:27:26Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ce90d90-5be7-4338-ac1b-8c09948c9f82",
        "parentId" : "af6eaacb-8960-4fe1-b0c2-c77380af8f94",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I do not know how to make suggestions for non-contiguous lines at once. ",
        "createdAt" : "2020-05-19T21:34:57Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "05c49bf7-f22a-40b0-803c-37f86220e68e",
        "parentId" : "af6eaacb-8960-4fe1-b0c2-c77380af8f94",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I did the multi line thing",
        "createdAt" : "2020-05-20T07:17:11Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9561715d-b0c8-4926-887c-85430c8d2731",
        "parentId" : "af6eaacb-8960-4fe1-b0c2-c77380af8f94",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@remyhaemmerle-da You can do multiline comments as shown in\r\nhttps://twitter.com/github/status/1179101186437324801?lang=en\r\nand then follow the regular suggestion workflow.",
        "createdAt" : "2020-05-20T08:19:07Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -1009,6 +1017,25 @@ private[lf] final case class Compiler(packages: PackageId PartialFunction Packag\n     }\n   }\n \n+  // Modify/extend `remaps` to reflect when new values are pushed on the stack. For SELet and SECase bindings\n+  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {\n+\n+    // We must update both the keys of the map (the relative-indexes from the original SEVar)\n+    // And also any values in the map which are stack located (SELocS), which are also indexed relatively\n+    val m1 = (remaps.toList.map { case (k, loc) => (n + k, shiftLoc(loc, n)) }.toMap)\n+\n+    // And create mappings for the `n` new stack items\n+    val m2 = (1 to n).map(i => (i, SELocS(i))).toMap\n+\n+    m1 ++ m2\n+  }\n+\n+  def shiftLoc(loc: SELoc, n: Int): SELoc = loc match {\n+    case SELocS(i) => SELocS(i + n)\n+    case SELocA(_) => loc"
  },
  {
    "id" : "fd509c3f-ff10-4af9-bc47-a0f3c4c62963",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "1e7e4aa0-b951-43fc-8aeb-9ed9203e218a",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-05-18T15:55:37Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -1009,6 +1017,25 @@ private[lf] final case class Compiler(packages: PackageId PartialFunction Packag\n     }\n   }\n \n+  // Modify/extend `remaps` to reflect when new values are pushed on the stack. For SELet and SECase bindings\n+  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {\n+\n+    // We must update both the keys of the map (the relative-indexes from the original SEVar)\n+    // And also any values in the map which are stack located (SELocS), which are also indexed relatively\n+    val m1 = (remaps.toList.map { case (k, loc) => (n + k, shiftLoc(loc, n)) }.toMap)\n+\n+    // And create mappings for the `n` new stack items\n+    val m2 = (1 to n).map(i => (i, SELocS(i))).toMap\n+\n+    m1 ++ m2\n+  }\n+\n+  def shiftLoc(loc: SELoc, n: Int): SELoc = loc match {\n+    case SELocS(i) => SELocS(i + n)\n+    case SELocA(_) => loc\n+    case SELocF(_) => loc"
  },
  {
    "id" : "231152ed-1b45-4621-8287-df6842961fda",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "1f41e9bd-bd08-4724-836e-72b669f3fd99",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let me guess, `scalafmt` does that to us. ðŸ˜¦",
        "createdAt" : "2020-05-19T17:13:41Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7c042f3b-25ef-418a-94bc-c6fee219f570",
        "parentId" : "1f41e9bd-bd08-4724-836e-72b669f3fd99",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I guess :man_shrugging: ",
        "createdAt" : "2020-05-20T07:04:09Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 4,
    "diffHunk" : "@@ -26,6 +26,7 @@ import scala.annotation.tailrec\n   * is exposed via ':speedy' command in the REPL.\n   */\n private[lf] object Compiler {\n+"
  },
  {
    "id" : "63881124-f062-487d-ade7-941055507b37",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "50ea9294-3ab8-48ab-a4ad-21f203d235bc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    *       Array(SELocS(2)),       [capture the first let-bound variable, from the stack]\r\n```",
        "createdAt" : "2020-05-19T17:14:59Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aed1eb55-00ae-472f-a11f-886d8f28a971",
        "parentId" : "50ea9294-3ab8-48ab-a4ad-21f203d235bc",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-05-20T07:04:23Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]"
  },
  {
    "id" : "5621b400-98a0-4dbf-ad7e-72ed1eba1240",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "8b64c5a9-6bac-4b17-937f-fbe7b4e04791",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    *       SELocF(0) ..            [reference the first let-bound variable via the closure]\r\n    *       SELocA(0))              [reference the first function arg]\r\n```",
        "createdAt" : "2020-05-19T17:15:41Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8348ca4a-58fc-4677-bd63-35cc8033a0b5",
        "parentId" : "8b64c5a9-6bac-4b17-937f-fbe7b4e04791",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-05-20T07:04:32Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]\n+    *       2,\n+    *       SELocF(0) ..            [reference the let-bound variable via the closure]\n+    *       SELocA(0))              [reference the function arg]"
  },
  {
    "id" : "41a76573-6a38-4972-b78e-251f06b7f451",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "4c9dfbfa-01e4-4ea5-aa4b-b94e38677139",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n      remaps.get(i).getOrElse(throw CompilationError(s\"remap($i),remaps=$remaps\"))\r\n```",
        "createdAt" : "2020-05-19T17:17:08Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 75,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]\n+    *       2,\n+    *       SELocF(0) ..            [reference the let-bound variable via the closure]\n+    *       SELocA(0))              [reference the function arg]\n     */\n-  def closureConvert(remaps: Map[Int, Int], bound: Int, expr: SExpr): SExpr = {\n-    def remap(i: Int): Int =\n-      remaps\n-        .get(bound - i)\n-        // map the absolute stack position back into a\n-        // relative position\n-        .map(bound - _)\n-        .getOrElse(i)\n+  def closureConvert(remaps: Map[Int, SELoc], expr: SExpr): SExpr = {\n+    // remaps is a function which maps the relative offset from variables (SEVar) to their runtime location\n+    // The Map must contain a binding for every variable referenced.\n+    // The Map is consulted when translating variable references (SEVar) and free variables of an abstraction (SEAbs)\n+    def remap(i: Int): SELoc = {\n+      remaps.get(i) match {\n+        case None => throw CompilationError(s\"remap($i),remaps=$remaps\")\n+        case Some(loc) => loc\n+      }"
  },
  {
    "id" : "98e4a514-cc81-4188-a4d5-30886ab17776",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "e7d8b05b-619b-434b-a3f7-28ba1382d9b8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n          i => i -> SELocA(arity - i)\r\n```",
        "createdAt" : "2020-05-19T17:19:01Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 110,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]\n+    *       2,\n+    *       SELocF(0) ..            [reference the let-bound variable via the closure]\n+    *       SELocA(0))              [reference the function arg]\n     */\n-  def closureConvert(remaps: Map[Int, Int], bound: Int, expr: SExpr): SExpr = {\n-    def remap(i: Int): Int =\n-      remaps\n-        .get(bound - i)\n-        // map the absolute stack position back into a\n-        // relative position\n-        .map(bound - _)\n-        .getOrElse(i)\n+  def closureConvert(remaps: Map[Int, SELoc], expr: SExpr): SExpr = {\n+    // remaps is a function which maps the relative offset from variables (SEVar) to their runtime location\n+    // The Map must contain a binding for every variable referenced.\n+    // The Map is consulted when translating variable references (SEVar) and free variables of an abstraction (SEAbs)\n+    def remap(i: Int): SELoc = {\n+      remaps.get(i) match {\n+        case None => throw CompilationError(s\"remap($i),remaps=$remaps\")\n+        case Some(loc) => loc\n+      }\n+    }\n     expr match {\n-      case SEVar(i) => SEVar(remap(i))\n+      case SEVar(i) => remap(i)\n       case v: SEVal => v\n       case be: SEBuiltin => be\n       case pl: SEValue => pl\n       case f: SEBuiltinRecursiveDefinition => f\n       case SELocation(loc, body) =>\n-        SELocation(loc, closureConvert(remaps, bound, body))\n+        SELocation(loc, closureConvert(remaps, body))\n \n       case SEAbs(0, _) =>\n         throw CompilationError(\"empty SEAbs\")\n \n-      case SEAbs(n, body) =>\n-        val fv = freeVars(body, n).toList.sorted\n-\n-        // remap free variables to new indices.\n-        // the index is the absolute position in stack.\n-        val newRemaps = fv.zipWithIndex.map {\n+      case SEAbs(arity, body) =>\n+        val fvs = freeVars(body, arity).toList.sorted\n+        val newRemapsF: Map[Int, SELoc] = fvs.zipWithIndex.map {\n           case (orig, i) =>\n-            // mapping from old position in the stack\n-            // to the new position\n-            (bound - orig) -> (bound - i - 1)\n+            (orig + arity) -> SELocF(i)\n         }.toMap\n-        val newBody = closureConvert(newRemaps, bound + n, body)\n-        SEMakeClo(fv.reverse.map(remap).toArray, n, newBody)\n+        val newRemapsA: Map[Int, SELoc] = (1 to arity).map {\n+          case i =>\n+            i -> SELocA(arity - i)"
  },
  {
    "id" : "a423413f-b8b2-4a67-a362-e974061fa219",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "d0a15ecf-420b-4b79-9c37-92bf92e4349e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume `++` takes the union of the two maps. What happens when the key sets overlap? Or is this impossible? Either way, a comment with a quick explanation would help.",
        "createdAt" : "2020-05-19T17:20:02Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ece8eca-a5f8-437e-993f-b41538b21089",
        "parentId" : "d0a15ecf-420b-4b79-9c37-92bf92e4349e",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "@martin-drhu-da \r\n'++' is very standard Scala. '++' is no really \"union\", but rather a foldLeft using \"+\" (insertion) (defined for all collections)\r\nFurthermore, the right hand side does not have to be a `Map[Key, Value]` but a `Traversable[(Key, Value)]`.\r\nSo the keys in right hand side map, override the one in the left hand side. \r\n\r\nAs another consequence the `toMap` in line 1029 is doing unnecessary work.",
        "createdAt" : "2020-05-19T21:48:09Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0b2a1d59-e67b-47ee-be95-09f126f51107",
        "parentId" : "d0a15ecf-420b-4b79-9c37-92bf92e4349e",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@nickchapman-da According to @remyhaemmerle-da, the keys in `newRemapsF` would win if there's a clash. However, I assume there are no clashes. If that's true, can you please leave a comment in the code to that effect?",
        "createdAt" : "2020-05-20T08:25:09Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]\n+    *       2,\n+    *       SELocF(0) ..            [reference the let-bound variable via the closure]\n+    *       SELocA(0))              [reference the function arg]\n     */\n-  def closureConvert(remaps: Map[Int, Int], bound: Int, expr: SExpr): SExpr = {\n-    def remap(i: Int): Int =\n-      remaps\n-        .get(bound - i)\n-        // map the absolute stack position back into a\n-        // relative position\n-        .map(bound - _)\n-        .getOrElse(i)\n+  def closureConvert(remaps: Map[Int, SELoc], expr: SExpr): SExpr = {\n+    // remaps is a function which maps the relative offset from variables (SEVar) to their runtime location\n+    // The Map must contain a binding for every variable referenced.\n+    // The Map is consulted when translating variable references (SEVar) and free variables of an abstraction (SEAbs)\n+    def remap(i: Int): SELoc = {\n+      remaps.get(i) match {\n+        case None => throw CompilationError(s\"remap($i),remaps=$remaps\")\n+        case Some(loc) => loc\n+      }\n+    }\n     expr match {\n-      case SEVar(i) => SEVar(remap(i))\n+      case SEVar(i) => remap(i)\n       case v: SEVal => v\n       case be: SEBuiltin => be\n       case pl: SEValue => pl\n       case f: SEBuiltinRecursiveDefinition => f\n       case SELocation(loc, body) =>\n-        SELocation(loc, closureConvert(remaps, bound, body))\n+        SELocation(loc, closureConvert(remaps, body))\n \n       case SEAbs(0, _) =>\n         throw CompilationError(\"empty SEAbs\")\n \n-      case SEAbs(n, body) =>\n-        val fv = freeVars(body, n).toList.sorted\n-\n-        // remap free variables to new indices.\n-        // the index is the absolute position in stack.\n-        val newRemaps = fv.zipWithIndex.map {\n+      case SEAbs(arity, body) =>\n+        val fvs = freeVars(body, arity).toList.sorted\n+        val newRemapsF: Map[Int, SELoc] = fvs.zipWithIndex.map {\n           case (orig, i) =>\n-            // mapping from old position in the stack\n-            // to the new position\n-            (bound - orig) -> (bound - i - 1)\n+            (orig + arity) -> SELocF(i)\n         }.toMap\n-        val newBody = closureConvert(newRemaps, bound + n, body)\n-        SEMakeClo(fv.reverse.map(remap).toArray, n, newBody)\n+        val newRemapsA: Map[Int, SELoc] = (1 to arity).map {\n+          case i =>\n+            i -> SELocA(arity - i)\n+        }.toMap\n+        val newBody = closureConvert(newRemapsA ++ newRemapsF, body)"
  },
  {
    "id" : "231da406-5041-4957-937c-c5c155867f6d",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "a50b17db-b906-49e6-8764-5f9c96eb2e8e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume we didn't need this before because of the `bound` parameter of `closureConvert`. Is that correct?",
        "createdAt" : "2020-05-19T17:21:54Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "16b9adae-c47a-4444-9615-177fb136e708",
        "parentId" : "a50b17db-b906-49e6-8764-5f9c96eb2e8e",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "?",
        "createdAt" : "2020-05-20T08:25:26Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a787f59a-93ad-416a-8476-c06f0dd7dfac",
        "parentId" : "a50b17db-b906-49e6-8764-5f9c96eb2e8e",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes. previously the re-mapping was performed in a context of absolute stack offsets.\r\nThis was *really really* hard to understand, although perhaps more efficient (at compile time).\r\n\r\nIt would be possible to do this still, at the cost of some confusion.\r\n\r\nBut a further problem is that the (SELocS) values of the map are also relative indexed.\r\nAnd so we either need a new type to represent SELoc-S(absolute)+A+F\r\nOr abuse the existing SELoc type.\r\nNeither choice seems very nice.\r\n\r\nActually, I would prefer if the SELocS could be actually be indexed absolutely.\r\nI think this would be slightly more efficient at runtime.\r\nI did have an experiment, but it runs in to issues regarding the way we handle the recursive builtins.\r\nSo I thought it best to leave this potential change to a later time.",
        "createdAt" : "2020-05-20T09:21:19Z",
        "updatedAt" : "2020-05-20T09:21:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 179,
    "diffHunk" : "@@ -1070,6 +1078,25 @@ private[lf] final case class Compiler(\n     }\n   }\n \n+  // Modify/extend `remaps` to reflect when new values are pushed on the stack. For SELet and SECase bindings\n+  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {"
  },
  {
    "id" : "20c5d9a1-5369-4c4a-89f6-2d6a03c15e4b",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "83de5546-e2f9-4d1f-b991-873543ebc959",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We're applying a monotonically strictly increasing function to the keys here. Hence, there's not real need to recompute the structure of the internal binary search tree again. Does `Map` expose a function like the following?\r\n```scala\r\nremaps.mapWithKeyMonotonic(k => n+k, loc => shiftLoc(loc, n))\r\n```",
        "createdAt" : "2020-05-19T17:25:57Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c95731de-2a08-46a4-a028-216f908c50ed",
        "parentId" : "83de5546-e2f9-4d1f-b991-873543ebc959",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    val m1 = remaps.map{ case (k, loc) => (n + k, shiftLoc(loc, n)) }\r\n```\r\n",
        "createdAt" : "2020-05-19T21:49:58Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e643c1f-ccdd-4508-968c-b2d16ea7287f",
        "parentId" : "83de5546-e2f9-4d1f-b991-873543ebc959",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "@martin-drhu-da wrote:\r\n> We're applying a monotonically strictly increasing function to the keys here. Hence, there's not real need to recompute the structure of the internal binary search tree again. Does `Map` expose a function like the following?\r\n> \r\n> ```scala\r\n> remaps.mapWithKeyMonotonic(k => n+k, loc => shiftLoc(loc, n))\r\n> ```\r\n\r\nI am not sure I follow. In scala default map are `HashMap` (hash trie to be precise) not `TreeMap`. \r\n",
        "createdAt" : "2020-05-19T21:52:55Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "374d0134-f2d8-4b39-8161-a888f9367f24",
        "parentId" : "83de5546-e2f9-4d1f-b991-873543ebc959",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Oh, I didn't know hash maps are the default. Then my comment is obsolete. Thanks for the explanation.",
        "createdAt" : "2020-05-20T08:21:47Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -1070,6 +1078,25 @@ private[lf] final case class Compiler(\n     }\n   }\n \n+  // Modify/extend `remaps` to reflect when new values are pushed on the stack. For SELet and SECase bindings\n+  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {\n+\n+    // We must update both the keys of the map (the relative-indexes from the original SEVar)\n+    // And also any values in the map which are stack located (SELocS), which are also indexed relatively\n+    val m1 = remaps.toList.map { case (k, loc) => (n + k, shiftLoc(loc, n)) }.toMap"
  },
  {
    "id" : "553e4235-c73b-4d87-b36e-775aaf424d38",
    "prId" : 6003,
    "comments" : [
      {
        "id" : "dec38148-f9f0-4778-a801-55cfb579d43d",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n        }\r\n```",
        "createdAt" : "2020-05-19T21:47:10Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "577cf6f0-cc76-40b1-bfb0-5a3802e3c5c4",
        "parentId" : "dec38148-f9f0-4778-a801-55cfb579d43d",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I tried this, but the scala type checker barfed.",
        "createdAt" : "2020-05-20T07:16:25Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d8aa9ed7-75b6-4d03-be4e-2897893d1a5c",
        "parentId" : "dec38148-f9f0-4778-a801-55cfb579d43d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Yep. You have to remove the type at line  1026",
        "createdAt" : "2020-05-20T07:28:07Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "61fff865-b6bc-43b2-9417-807531b196c3",
        "parentId" : "dec38148-f9f0-4778-a801-55cfb579d43d",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "thanks",
        "createdAt" : "2020-05-20T09:03:23Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : null,
    "diffHunk" : "@@ -983,84 +983,92 @@ private[lf] final case class Compiler(\n     * describing the free variables that need to be captured.\n     *\n     * For example:\n-    *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *   SELet(..two-bindings..) in\n+    *     SEAbs(2,\n+    *       SEVar(4) ..             [reference to first let-bound variable]\n+    *       SEVar(2))               [reference to first function-arg]\n     * =>\n-    *   SELet(...) in\n+    *   SELet(..two-bindings..) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n-    *       2, (still takes two arguments)\n-    *       SEVar(3)) (variable now first value after args)\n+    *       Array(SELocS(2)),       [capture the let-bound variable, from the stack]\n+    *       2,\n+    *       SELocF(0) ..            [reference the let-bound variable via the closure]\n+    *       SELocA(0))              [reference the function arg]\n     */\n-  def closureConvert(remaps: Map[Int, Int], bound: Int, expr: SExpr): SExpr = {\n-    def remap(i: Int): Int =\n-      remaps\n-        .get(bound - i)\n-        // map the absolute stack position back into a\n-        // relative position\n-        .map(bound - _)\n-        .getOrElse(i)\n+  def closureConvert(remaps: Map[Int, SELoc], expr: SExpr): SExpr = {\n+    // remaps is a function which maps the relative offset from variables (SEVar) to their runtime location\n+    // The Map must contain a binding for every variable referenced.\n+    // The Map is consulted when translating variable references (SEVar) and free variables of an abstraction (SEAbs)\n+    def remap(i: Int): SELoc = {\n+      remaps.get(i) match {\n+        case None => throw CompilationError(s\"remap($i),remaps=$remaps\")\n+        case Some(loc) => loc\n+      }\n+    }\n     expr match {\n-      case SEVar(i) => SEVar(remap(i))\n+      case SEVar(i) => remap(i)\n       case v: SEVal => v\n       case be: SEBuiltin => be\n       case pl: SEValue => pl\n       case f: SEBuiltinRecursiveDefinition => f\n       case SELocation(loc, body) =>\n-        SELocation(loc, closureConvert(remaps, bound, body))\n+        SELocation(loc, closureConvert(remaps, body))\n \n       case SEAbs(0, _) =>\n         throw CompilationError(\"empty SEAbs\")\n \n-      case SEAbs(n, body) =>\n-        val fv = freeVars(body, n).toList.sorted\n-\n-        // remap free variables to new indices.\n-        // the index is the absolute position in stack.\n-        val newRemaps = fv.zipWithIndex.map {\n+      case SEAbs(arity, body) =>\n+        val fvs = freeVars(body, arity).toList.sorted\n+        val newRemapsF: Map[Int, SELoc] = fvs.zipWithIndex.map {\n           case (orig, i) =>\n-            // mapping from old position in the stack\n-            // to the new position\n-            (bound - orig) -> (bound - i - 1)\n+            (orig + arity) -> SELocF(i)\n         }.toMap\n-        val newBody = closureConvert(newRemaps, bound + n, body)\n-        SEMakeClo(fv.reverse.map(remap).toArray, n, newBody)\n+        val newRemapsA: Map[Int, SELoc] = (1 to arity).map {\n+          case i =>\n+            i -> SELocA(arity - i)\n+        }.toMap"
  },
  {
    "id" : "5deacbe7-36dd-4d6a-8f83-3c1231e763ae",
    "prId" : 5957,
    "comments" : [
      {
        "id" : "0e2ec55d-8c21-48f6-84fd-56603e972e9a",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n  sealed abstract class ProfilingMode extends Product with Serializable\r\n```\r\n\r\nIn general for ADT roots when all subclasses are `case`s.",
        "createdAt" : "2020-05-15T20:12:05Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "11e90cf4-6cb0-4a40-8f10-cdf0caf77856",
        "parentId" : "0e2ec55d-8c21-48f6-84fd-56603e972e9a",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What does this do and what's the benefit of doing it?",
        "createdAt" : "2020-05-18T16:08:49Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f9c37f8-a7c0-4e97-84f2-9923ce68b2ae",
        "parentId" : "0e2ec55d-8c21-48f6-84fd-56603e972e9a",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Same as scala/bug#9173, with the fix being scala/scala#4355 in that case.\r\n\r\nIt also eliminates false positives on the `Product` and `Serializable` warts.",
        "createdAt" : "2020-05-18T16:21:48Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9b07b9b6bb0bb079c6a380804dc18a83f562c379",
    "line" : null,
    "diffHunk" : "@@ -30,6 +30,13 @@ private[lf] object Compiler {\n   case class PackageNotFound(pkgId: PackageId)\n       extends RuntimeException(s\"Package not found $pkgId\", null, true, false)\n \n+  // NOTE(MH): We make this an enum type to avoid boolean blindness. In fact,\n+  // other profiling modes like \"only trace the ledger interactions\" might also\n+  // be useful.\n+  sealed abstract class ProfilingMode"
  },
  {
    "id" : "5f789a27-3d2c-44cf-9e06-4b0243c67397",
    "prId" : 5957,
    "comments" : [
      {
        "id" : "190cb354-2c48-4104-9177-5ee41da7f525",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "`{}` are not really part of the function syntax, nor the `case` syntax, irrespective of IDEA's obsession with them. There are occasionally good reasons to use them with functions, but never with `case` per se.\r\n\r\n```suggestion\r\n      case NoProfile => (_, expr) => expr\r\n      case FullProfile => (label, expr) =>\r\n        expr match {\r\n          case SELabelClosure(_, expr1) => SELabelClosure(label, expr1)\r\n          case _ => SELabelClosure(label, expr)\r\n        }\r\n```",
        "createdAt" : "2020-05-15T20:18:22Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6c3c3d47-b807-4f4a-8dff-18a288c6eaef",
        "parentId" : "190cb354-2c48-4104-9177-5ee41da7f525",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I find the `case x => y => z` syntax quite confusing because the two occurrences of `=>` don't mean exactly the same thing. I was looking for some scoping construct to put in between them. Could I just use `(...)`?",
        "createdAt" : "2020-05-18T16:12:09Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b4324ee3-b8ac-4c0f-bd07-0be9d7f12860",
        "parentId" : "190cb354-2c48-4104-9177-5ee41da7f525",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> Could I just use `(...)`?\r\n\r\nYes.",
        "createdAt" : "2020-05-18T16:13:34Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9b07b9b6bb0bb079c6a380804dc18a83f562c379",
    "line" : 51,
    "diffHunk" : "@@ -122,6 +132,25 @@ private[lf] final case class Compiler(packages: PackageId PartialFunction Packag\n   /** Environment mapping names into stack positions */\n   private var env = Env()\n \n+  private val withLabel: (AnyRef, SExpr) => SExpr =\n+    profiling match {\n+      case NoProfile => { (_, expr) =>\n+        expr\n+      }\n+      case FullProfile => { (label, expr) =>\n+        expr match {\n+          case SELabelClosure(_, expr1) => SELabelClosure(label, expr1)\n+          case _ => SELabelClosure(label, expr)\n+        }\n+      }"
  },
  {
    "id" : "862be724-d0b8-4bea-a35d-f501f44d2320",
    "prId" : 5819,
    "comments" : [
      {
        "id" : "993708aa-d2b4-4211-be18-5adc35e3797a",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I am not sure we should use \"Compile\" for the name of this function.",
        "createdAt" : "2020-05-05T12:06:33Z",
        "updatedAt" : "2020-05-11T08:59:50Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4d1734369ae2276cb8e1c399796673b4b2ffe9e3",
    "line" : 7,
    "diffHunk" : "@@ -132,6 +132,11 @@ private[lf] final case class Compiler(packages: PackageId PartialFunction Packag\n   def unsafeCompile(expr: Expr): SExpr =\n     validate(closureConvert(Map.empty, 0, translate(expr)))\n \n+  @throws[PackageNotFound]\n+  @throws[CompilationError]\n+  def unsafeCompile(sexpr: SExpr): SExpr =\n+    validate(closureConvert(Map.empty, 0, sexpr))"
  },
  {
    "id" : "1cbdb699-8712-4bf0-b743-e6f4ebd10277",
    "prId" : 5629,
    "comments" : [
      {
        "id" : "821f15c9-6e98-4723-a199-eadb9b80b519",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Might we worth explaining that we use `dependenciesInTopologicalOrder` because packages need to be compiled in order. Perhaps that's obvious to others though.",
        "createdAt" : "2020-04-20T13:15:56Z",
        "updatedAt" : "2020-04-20T14:48:19Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "65d9657b-9b77-4bfa-a14d-414cb7e1c41f",
        "parentId" : "821f15c9-6e98-4723-a199-eadb9b80b519",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-04-20T14:08:27Z",
        "updatedAt" : "2020-04-20T14:48:19Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f58847316bfebf75c98029bd4ce800560e794f7",
    "line" : 43,
    "diffHunk" : "@@ -153,32 +152,14 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n     * The packages do not need to be in any specific order, as long as they and all the packages\n     * they transitively reference are in the [[packages]] in the compiler.\n     */\n-  @throws(classOf[PackageNotFound])\n-  def compilePackages(toCompile0: Iterable[PackageId]): Map[SDefinitionRef, SExpr] = {\n-    var defns = Map.empty[SDefinitionRef, SExpr]\n-    val compiled = mutable.Set.empty[PackageId]\n-    var toCompile = toCompile0.toList\n-    val foundDependencies = mutable.Set.empty[PackageId]\n-\n-    while (toCompile.nonEmpty) {\n-      val pkgId = toCompile.head\n-      toCompile = toCompile.tail\n-      try {\n-        if (!compiled.contains(pkgId))\n-          defns ++= compilePackage(pkgId)\n-      } catch {\n-        case PackageNotFound(dependency) if dependency != pkgId =>\n-          if (foundDependencies.contains(dependency)) {\n-            throw CompileError(s\"Cyclical packages, stumbled upon $dependency twice\")\n-          }\n-          foundDependencies += dependency\n-          toCompile = dependency :: pkgId :: toCompile\n-      }\n-      compiled += pkgId\n-    }\n-\n-    defns\n-  }\n+  @throws[PackageNotFound]\n+  @throws[CompileError]\n+  @throws[ValidationError]\n+  def compilePackages(toCompile: Iterable[PackageId]): Map[SDefinitionRef, SExpr] =\n+    dependenciesInTopologicalOrder(toCompile.toList, packages)"
  },
  {
    "id" : "cf58a3aa-0c18-4c86-bc8d-abec77ea7bf1",
    "prId" : 5602,
    "comments" : [
      {
        "id" : "ac756169-2f66-48be-b0c7-3f13fe7b4c76",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Do you want to update the comment above how choices are compiled, i.e., add a byKey parameter to the abstraction?",
        "createdAt" : "2020-04-21T08:52:17Z",
        "updatedAt" : "2020-04-21T15:25:25Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "91cfc7d7-1eb5-40ef-a8d4-5b5b3e7749e4",
        "parentId" : "ac756169-2f66-48be-b0c7-3f13fe7b4c76",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I was a bit too quick to add you as reviewer. This was done in the previous PR. It is rebase now. ",
        "createdAt" : "2020-04-21T08:53:45Z",
        "updatedAt" : "2020-04-21T15:25:25Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f48c609-2027-44d2-b629-0aff93793212",
        "parentId" : "ac756169-2f66-48be-b0c7-3f13fe7b4c76",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "On the other hand, why do you even need to pass the `byKey` flag through the compiled DAML code? Whether this is a byKey choice is known statically. So if you move the `byKey` flag into the first argument list for `SBUBeginExercise`, you shouldn't have to pass this around. But you know the internals better than I do.",
        "createdAt" : "2020-04-21T08:56:07Z",
        "updatedAt" : "2020-04-21T15:25:25Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9b700bd7-2494-49ec-b386-807bca0f6b41",
        "parentId" : "ac756169-2f66-48be-b0c7-3f13fe7b4c76",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "A choice is  compiled into a speedy function when the archive is loaded (see the function `compileChoice`). The resulting function is used for both kind of exercises (see `compileExercise` and `compileExerciseByKey`). The changes you advocate needs deeper refactoring; this probably needs to generate two functions for each choice a template with key.\r\nI am not sure it is worthwhile.  ",
        "createdAt" : "2020-04-21T09:12:02Z",
        "updatedAt" : "2020-04-21T15:25:25Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0bd4ae24-1c1e-4dc3-8bf6-6806b5537f2a",
        "parentId" : "ac756169-2f66-48be-b0c7-3f13fe7b4c76",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Thanks for the explanation. And yes, you'd need to functions for implementing my proposal; I didn't know about the load-vs-run distinction. My proposal then boils down to specializing the current function into two. We have other performance bottlenecks to sort out first.",
        "createdAt" : "2020-04-21T09:25:58Z",
        "updatedAt" : "2020-04-21T15:25:25Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "12774e20c4282ed17ba9ed7574e4c54178ddf321",
    "line" : null,
    "diffHunk" : "@@ -776,6 +783,7 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n         Map.empty,\n         0,\n         withEnv { _ =>\n+          env = env.incrPos // byKey flag"
  },
  {
    "id" : "086612f5-c3d8-4159-8109-6c56bb089431",
    "prId" : 5599,
    "comments" : [
      {
        "id" : "6c36c2b2-d726-440b-b932-033d629fe5b3",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please add the `byKey` flag to the various `// stack:` comments.",
        "createdAt" : "2020-04-20T13:45:14Z",
        "updatedAt" : "2020-04-20T15:58:39Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "23e196c4-95ed-464f-b52d-5e6d020c4a3c",
        "parentId" : "6c36c2b2-d726-440b-b932-033d629fe5b3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Good catch ",
        "createdAt" : "2020-04-20T14:20:00Z",
        "updatedAt" : "2020-04-20T15:58:39Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f0189c3bb44080d20e974665a0e1881033d83ea",
    "line" : null,
    "diffHunk" : "@@ -809,6 +817,7 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n                 SEVar(3), // choice argument\n                 SEVar(4), // cid\n                 SEVar(5), // actors\n+                SEVar(6), // byKey flag"
  },
  {
    "id" : "3c2f5157-3309-41cf-9ccb-35e05fdc92a5",
    "prId" : 5599,
    "comments" : [
      {
        "id" : "a7cae0c0-fc7d-49aa-b79e-ac86188f9a8c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think `byKey` still needs to be reflected in line 777.",
        "createdAt" : "2020-04-20T15:42:37Z",
        "updatedAt" : "2020-04-20T15:58:39Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f933dc4c-e590-413c-9a74-42d62d355bb6",
        "parentId" : "a7cae0c0-fc7d-49aa-b79e-ac86188f9a8c",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Indeed. Line 775 as well. ",
        "createdAt" : "2020-04-20T15:56:08Z",
        "updatedAt" : "2020-04-20T15:58:39Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f0189c3bb44080d20e974665a0e1881033d83ea",
    "line" : null,
    "diffHunk" : "@@ -776,6 +783,7 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n         Map.empty,\n         0,\n         withEnv { _ =>\n+          env = env.incrPos // byKey flag"
  },
  {
    "id" : "e8970d13-4959-4967-905b-500f01a48a66",
    "prId" : 4990,
    "comments" : [
      {
        "id" : "9ef3c755-f27e-4307-acdd-d589de8c0aad",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why the `//`s?",
        "createdAt" : "2020-03-13T15:48:50Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ffe53e6-1c6e-460f-bf95-0b8c4d54b18d",
        "parentId" : "9ef3c755-f27e-4307-acdd-d589de8c0aad",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "trying to fight against auto-formatter.\r\n\r\ndropped ",
        "createdAt" : "2020-03-13T16:13:16Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "388d7c03ab7235b2099abd7694f5a70a401bfdd4",
    "line" : null,
    "diffHunk" : "@@ -322,8 +312,10 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n               case BTextIntercalate => SBTextIntercalate\n \n               // Implemented using normal SExpr\n-              case BFoldl | BFoldr | BEqualList | BCoerceContractId | BTextMapEmpty |\n-                  BGenMapEmpty =>\n+              case BFoldl | BFoldr | BCoerceContractId | //"
  },
  {
    "id" : "17a49e45-566b-4167-a53b-b0d5775d96af",
    "prId" : 4990,
    "comments" : [
      {
        "id" : "f0ae1b34-c83b-4c5b-82f0-8f1033ab9b2c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Is this to \"drop\" one of the parameters?",
        "createdAt" : "2020-03-16T11:11:54Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bc5309b0-ea03-46e4-be61-ef6e2964684f",
        "parentId" : "f0ae1b34-c83b-4c5b-82f0-8f1033ab9b2c",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "This drop the type parameter `nat`, which is nor erase.   ",
        "createdAt" : "2020-03-16T12:11:51Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "388d7c03ab7235b2099abd7694f5a70a401bfdd4",
    "line" : 5,
    "diffHunk" : "@@ -194,6 +194,17 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n   private val compileGetTime: SExpr =\n     SEAbs(1) { SBGetTime(SEVar(1)) }\n \n+  private val SBLessNumeric =\n+    SEAbs(3, SEApp(SEBuiltin(SBLess), Array(SEVar(2), SEVar(1))))"
  },
  {
    "id" : "09ef2d18-807b-4a91-a674-0668c4c895a9",
    "prId" : 3431,
    "comments" : [
      {
        "id" : "618f94fb-3b27-4a11-a842-2226ad3f2134",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n              // GenMap\r\n```",
        "createdAt" : "2019-11-12T12:29:42Z",
        "updatedAt" : "2019-11-12T13:24:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "100650c2b9398b69a6f0315c442acedb917736c5",
    "line" : null,
    "diffHunk" : "@@ -307,6 +307,16 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n               case BMapToList => SBMapToList\n               case BMapSize => SBMapSize\n \n+              // GebMap"
  },
  {
    "id" : "73ec345f-14fe-41b1-ab5f-e56c5152b8c2",
    "prId" : 3293,
    "comments" : [
      {
        "id" : "aa3c1f93-68aa-460d-a12f-16e65e472a17",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Rename to `typeCon`?\r\n```suggestion\r\n      case EToTextTypeConName(typeCon) =>\r\n```",
        "createdAt" : "2019-10-30T14:28:48Z",
        "updatedAt" : "2019-10-30T14:54:14Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "21966e0332a605efb87463491d305a573f02db43",
    "line" : null,
    "diffHunk" : "@@ -598,8 +598,8 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n       case EFromAny(ty, e) =>\n         SEApp(SEBuiltin(SBFromAny(ty)), Array(translate(e)))\n \n-      case EToTextTemplateId(tmplId) =>\n-        SEBuiltin(SBToTextTemplateId(tmplId))\n+      case EToTextTypeConName(tmplId) =>"
  },
  {
    "id" : "7c38d484-fd3b-4459-b893-f6b9f7db3e82",
    "prId" : 3115,
    "comments" : [
      {
        "id" : "7b88e581-051e-4908-a9b5-28766fb93fd0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think this check should probably be done during typechecking not in the compiler.",
        "createdAt" : "2019-10-07T08:38:17Z",
        "updatedAt" : "2019-10-07T11:10:04Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d3f1cc55-c7b9-442a-83fc-46c939b0a4f6",
        "parentId" : "7b88e581-051e-4908-a9b5-28766fb93fd0",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yes, it'll be checked in the typechecker. I've removed this for being redundant.",
        "createdAt" : "2019-10-07T11:01:14Z",
        "updatedAt" : "2019-10-07T11:10:04Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5bb1e9d7c998101d7649c6fbfc26715c6c7245b3",
    "line" : null,
    "diffHunk" : "@@ -594,6 +594,12 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n \n       case EFromAnyTemplate(tmplId, e) =>\n         SEApp(SEBuiltin(SBFromAnyTemplate(tmplId)), Array(translate(e)))\n+\n+      case ETyCon(tyCon) =>\n+        // Ensure that the type is known."
  },
  {
    "id" : "dbcd2411-3019-49a9-b321-5eebff3e9a15",
    "prId" : 2860,
    "comments" : [
      {
        "id" : "15838414-edb2-424e-843f-2be04b5c14c4",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  private[this] val logger = LoggerFactory.getLogger(this.getClass)\r\n```\r\nIn this case `private[this]` makes a lot of sense. :slightly_smiling_face: ",
        "createdAt" : "2019-09-10T13:29:09Z",
        "updatedAt" : "2019-09-13T09:55:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "66feacefba7b54019abe3376660df6e5301c989f",
    "line" : 21,
    "diffHunk" : "@@ -38,6 +39,7 @@ object Compiler {\n }\n \n final case class Compiler(packages: PackageId PartialFunction Package) {\n+  private val logger = LoggerFactory.getLogger(this.getClass)"
  },
  {
    "id" : "fc1c672e-48f9-4aaa-912b-424cbd6b2756",
    "prId" : 2653,
    "comments" : [
      {
        "id" : "9830ac13-1e5a-497d-9bbf-1dc17679fe07",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "revert the renames",
        "createdAt" : "2019-08-26T11:51:13Z",
        "updatedAt" : "2019-08-26T15:11:51Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "de1eb982-f4ad-4160-b793-e67955f106eb",
        "parentId" : "9830ac13-1e5a-497d-9bbf-1dc17679fe07",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-08-26T12:37:43Z",
        "updatedAt" : "2019-08-26T15:11:51Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0fa6077c71edb857ab4a0a3851d841ea21acc8ef",
    "line" : null,
    "diffHunk" : "@@ -855,13 +880,13 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n     *\n     * For example:\n     *   SELet(...) in\n-    *     SEAbs(2, SEVar(4))\n+    *     SEAbs(2, SVar(4))\n     * =>\n     *   SELet(...) in\n     *     SEMakeClo(\n-    *       Array(SEVar(2)), (capture 2nd value)\n+    *       Array(SVar(2)), (capture 2nd value)"
  },
  {
    "id" : "4f7bc212-f394-468f-8344-ef3f43fff79e",
    "prId" : 2653,
    "comments" : [
      {
        "id" : "c9d45e1a-c8d3-4d08-bf12-78824a2aa060",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "revert rename",
        "createdAt" : "2019-08-26T11:51:31Z",
        "updatedAt" : "2019-08-26T15:11:51Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "530b926a-1882-4d94-b10b-990167871571",
        "parentId" : "c9d45e1a-c8d3-4d08-bf12-78824a2aa060",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed ",
        "createdAt" : "2019-08-26T12:38:14Z",
        "updatedAt" : "2019-08-26T15:11:51Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0fa6077c71edb857ab4a0a3851d841ea21acc8ef",
    "line" : null,
    "diffHunk" : "@@ -1003,7 +1028,7 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n       expr match {\n         case SEVar(i) =>\n           if (i < 1 || i > bound) {\n-            throw CompileError(s\"validate: SEVar: index $i out of bound $bound\")\n+            throw CompileError(s\"validate: SVar: index $i out of bound $bound\")"
  },
  {
    "id" : "ff68b556-0fa3-4374-ad27-d0a1718b6612",
    "prId" : 1414,
    "comments" : [
      {
        "id" : "5a49fe65-4f32-4ae0-9ce3-36a9f159d2f2",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "explain why this is optional now",
        "createdAt" : "2019-06-04T13:49:06Z",
        "updatedAt" : "2019-06-28T13:00:45Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d32d0950-f462-4da1-832a-80a7d9593eab",
        "parentId" : "5a49fe65-4f32-4ae0-9ce3-36a9f159d2f2",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "That's a good catch. It's actually never `Some` any more, so I removed it as a parameter now. In general, exercise actors are computed from the controllers in the new versions of LF, and the compiler does not set them any more. I've added a comment to `compileExercise` to this effect.",
        "createdAt" : "2019-06-07T15:09:21Z",
        "updatedAt" : "2019-06-28T13:00:45Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ab0ead601a9595d13f63af85647223621775e3eb",
    "line" : 20,
    "diffHunk" : "@@ -1157,14 +1157,14 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n       // actors are either the singleton set of submitter of an exercise command,\n       // or the acting parties of an exercise node\n       // of a transaction under reconstruction for validation\n-      actors: SExpr): SExpr = {"
  },
  {
    "id" : "6751afbd-b848-408c-8648-8eab76fe8216",
    "prId" : 1346,
    "comments" : [
      {
        "id" : "a7e8aee1-fe6f-4c04-a7b2-ea958205ad80",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@neil-da That's the Scala implementation: `\\x -> x`.",
        "createdAt" : "2019-05-23T13:27:45Z",
        "updatedAt" : "2019-05-23T13:31:31Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e5232022-19fb-4fcd-8d53-386dcca53eaf",
        "parentId" : "a7e8aee1-fe6f-4c04-a7b2-ea958205ad80",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "So simples :)",
        "createdAt" : "2019-05-23T21:20:50Z",
        "updatedAt" : "2019-05-23T21:20:50Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5e330f2532a8450673c29e65222e4e4d6688f6e5",
    "line" : 4,
    "diffHunk" : "@@ -144,6 +144,7 @@ final case class Compiler(packages: PackageId PartialFunction Package) {\n           case BFoldl => SEBuiltinRecursiveDefinition.FoldL\n           case BFoldr => SEBuiltinRecursiveDefinition.FoldR\n           case BEqualList => SEBuiltinRecursiveDefinition.EqualList\n+          case BCoerceContractId => SEAbs(1, SEVar(1))"
  }
]