[
  {
    "id" : "38025611-7847-416d-b6a1-001b315f3808",
    "prId" : 7326,
    "comments" : [
      {
        "id" : "0562146f-aaa7-49af-8884-6316c87b3163",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why can we delete all the stuff in here?",
        "createdAt" : "2020-09-08T11:09:00Z",
        "updatedAt" : "2020-09-08T12:58:37Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "494a9257-ceb3-4128-894c-50c00b13a3d8",
        "parentId" : "0562146f-aaa7-49af-8884-6316c87b3163",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "This is tested extensively in [ComparisonSBuiltinTest](https://github.com/digital-asset/daml/blob/master/daml-lf/interpreter/src/test/scala/com/digitalasset/daml/lf/speedy/ComparisonSBuiltinTest.scala)",
        "createdAt" : "2020-09-08T12:23:43Z",
        "updatedAt" : "2020-09-08T12:58:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "620b799dfe99df2b5819c91217f1681670647668",
    "line" : 4,
    "diffHunk" : "@@ -4,10 +4,7 @@\n package com.daml.lf.speedy\n package svalue\n \n-import java.util"
  },
  {
    "id" : "d79b2635-60b1-44a3-838f-9020af898970",
    "prId" : 6038,
    "comments" : [
      {
        "id" : "8083d0b1-9ab8-48fd-a993-a5b9e008c1b0",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "`inj` gives us transaction library `Value`s for free, but not `SValue`s. We could go through the `translatePrimValue` conversion instead, or define an associated `injSvalue` paired with each `ValueAddend` constructor we care to use. Of course for a small number of cases it's sufficient and safe to hand-write as done above.",
        "createdAt" : "2020-05-19T21:44:29Z",
        "updatedAt" : "2020-05-27T23:17:58Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c429d96b104ad601a23dec9fe0fc8eb6d1fe17c3",
    "line" : 44,
    "diffHunk" : "@@ -326,6 +329,27 @@ class OrderingSpec\n     Table(\"any\", anys: _*),\n   )\n \n+  private val randomComparableValues: TableFor2[String, Gen[SValue]] = {\n+    import com.daml.lf.value.TypedValueGenerators.{ValueAddend => VA}\n+    implicit val ordNo\n+      : Order[Nothing] = Order order [Nothing]((_: Any, _: Any) => sys.error(\"impossible\"))\n+    def r(name: String, va: VA)(sv: va.Inj[Nothing] => SValue) =\n+      (name, va.injarb[Nothing].arbitrary map sv)\n+    Table(\n+      (\"comparable value subset\", \"generator\"),\n+      Seq(\n+        r(\"Int64\", VA.int64)(SInt64),\n+        r(\"Text\", VA.text)(SText),\n+        r(\"Int64 Option List\", VA.list(VA.optional(VA.int64))) { loi =>\n+          SList(loi.map(oi => SOptional(oi map SInt64)).to[FrontStack])\n+        },"
  },
  {
    "id" : "9166aa42-c804-4854-8255-e0cb1746d82f",
    "prId" : 6038,
    "comments" : [
      {
        "id" : "97cef631-b726-4a99-b777-0c14d5004552",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Includes reflexive, antisymmetric, transitive.",
        "createdAt" : "2020-05-19T21:48:25Z",
        "updatedAt" : "2020-05-27T23:17:58Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c429d96b104ad601a23dec9fe0fc8eb6d1fe17c3",
    "line" : 62,
    "diffHunk" : "@@ -437,6 +461,13 @@ class OrderingSpec\n       }\n     }\n \n+    \"be lawful on each subset\" in forEvery(randomComparableValues) { (_, svGen) =>\n+      implicit val svalueOrd: Order[SValue] = Order fromScalaOrdering Ordering\n+      implicit val svalueArb: Arbitrary[SValue] = Arbitrary(svGen)\n+      forEvery(Table((\"law\", \"prop\"), SzP.order.laws[SValue].properties: _*)) { (_, p) =>"
  },
  {
    "id" : "2a39eb93-c4e7-4b4d-bc31-a81ad1300048",
    "prId" : 5881,
    "comments" : [
      {
        "id" : "56c6539b-2996-4863-b7f1-1ce21b53ca4f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please use named arguments for all the arguments here? The list is quite unwieldy already.",
        "createdAt" : "2020-05-07T07:39:38Z",
        "updatedAt" : "2020-05-07T07:58:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e64d616c07b79eb94e74bcd9fdf26b01521b9b5c",
    "line" : 21,
    "diffHunk" : "@@ -475,17 +474,17 @@ class OrderingSpec\n     new util.ArrayList[X](as.asJava)\n \n   private val txSeed = crypto.Hash.hashPrivateKey(\"SBuiltinTest\")\n-  private def dummyMachine = Speedy.Machine fromExpr (\n-    expr = e\"NA:na ()\",\n+  private def initMachine(expr: SExpr) = Speedy.Machine fromSExpr (\n+    sexpr = expr,\n     compiledPackages = PureCompiledPackages(Map.empty, Map.empty),\n-    scenario = false,\n     Time.Timestamp.now(),\n-    Some(txSeed),\n+    InitialSeeding(Some(txSeed)),\n+    Set.empty,"
  },
  {
    "id" : "4cf7cee4-ded6-482d-a546-2059565d0dfb",
    "prId" : 5881,
    "comments" : [
      {
        "id" : "d3fc7a8c-4cd2-455f-ba3f-1dabe571d114",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's keep it concise. ðŸ˜ƒ\r\n```suggestion\r\n    val machine = initMachine(SEImportValue(v))\r\n```",
        "createdAt" : "2020-05-07T07:40:19Z",
        "updatedAt" : "2020-05-07T07:58:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e64d616c07b79eb94e74bcd9fdf26b01521b9b5c",
    "line" : 28,
    "diffHunk" : "@@ -475,17 +474,17 @@ class OrderingSpec\n     new util.ArrayList[X](as.asJava)\n \n   private val txSeed = crypto.Hash.hashPrivateKey(\"SBuiltinTest\")\n-  private def dummyMachine = Speedy.Machine fromExpr (\n-    expr = e\"NA:na ()\",\n+  private def initMachine(expr: SExpr) = Speedy.Machine fromSExpr (\n+    sexpr = expr,\n     compiledPackages = PureCompiledPackages(Map.empty, Map.empty),\n-    scenario = false,\n     Time.Timestamp.now(),\n-    Some(txSeed),\n+    InitialSeeding(Some(txSeed)),\n+    Set.empty,\n   )\n \n   private def translatePrimValue(v: Value[Value.AbsoluteContractId]) = {\n-    val machine = dummyMachine\n-    machine.ctrl = SEImportValue(v)\n+    val expr = SEImportValue(v)\n+    val machine = initMachine(expr)"
  },
  {
    "id" : "4b282b1a-3027-4c29-9a34-81eb0b5cb0f7",
    "prId" : 5526,
    "comments" : [
      {
        "id" : "e9993971-d5ff-4730-8529-26bda50555a1",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Good.",
        "createdAt" : "2020-04-14T08:00:07Z",
        "updatedAt" : "2020-04-24T20:58:40Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5e1355a2c792b820752b3f4a7fe7b384b7ef174c",
    "line" : 71,
    "diffHunk" : "@@ -420,7 +438,33 @@ class OrderingSpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n \n   }\n \n+  \"txn Value Ordering\" should {\n+    import Value.{AbsoluteContractId => Cid}\n+    implicit val cidArb: Arbitrary[Cid] = Arbitrary(absCoidGen)\n+    val EmptyScope: Value.LookupVariantEnum = _ => None\n+    \"match SValue Ordering\" in forAll(genAddend, minSuccessful(100)) { va =>\n+      import va.{injarb, injshrink}\n+      implicit val svalueOrd: Order[SValue] = Order fromScalaOrdering Ordering\n+      implicit val cidOrd: Order[Cid] = svalueOrd contramap SValue.SContractId\n+      implicit val valueOrd: Order[Value[Cid]] = Tag unsubst Value.orderInstance[Cid](EmptyScope)\n+      forAll(minSuccessful(20)) { (a: va.Inj[Cid], b: va.Inj[Cid]) =>\n+        val ta = va.inj(a)\n+        val tb = va.inj(b)\n+        (ta ?|? tb) should ===(translatePrimValue(ta) ?|? translatePrimValue(tb))\n+      }\n+    }\n+  }"
  },
  {
    "id" : "b1668cce-c759-4068-8921-f1991dfafcf7",
    "prId" : 5048,
    "comments" : [
      {
        "id" : "6ae6aaf0-74a6-4f8e-8023-d8b90921f901",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why does this constructor rank not start with `0`?",
        "createdAt" : "2020-03-18T07:16:31Z",
        "updatedAt" : "2020-03-18T12:46:43Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1832d3c9-fdff-4b6a-a7e8-faf90caf32e9",
        "parentId" : "6ae6aaf0-74a6-4f8e-8023-d8b90921f901",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I will fix that.",
        "createdAt" : "2020-03-18T08:07:27Z",
        "updatedAt" : "2020-03-18T12:46:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a58b8b64400741795af304d763a8e244b07dcb09",
    "line" : null,
    "diffHunk" : "@@ -357,8 +360,8 @@ class OrderingSpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n       STextMap(HashMap.empty) ->\n         STextMap(HashMap(\"a\" -> lfFunction)),\n       SGenMap.Empty -> SGenMap(SInt64(0) -> lfFunction),\n-      SVariant(VariantTypeCon, VariantCon1, SInt64(0)) ->\n-        SVariant(VariantTypeCon, VariantCon2, lfFunction),\n+      SVariant(VariantTypeCon, VariantCon1, 1, SInt64(0)) ->"
  },
  {
    "id" : "c170c01d-909f-4079-9bf2-76e87bf7c9b6",
    "prId" : 5048,
    "comments" : [
      {
        "id" : "8ab2e92a-f602-48fd-9791-9c034cd15044",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why does this constructor rank not start with `0`?",
        "createdAt" : "2020-03-18T07:16:57Z",
        "updatedAt" : "2020-03-18T12:46:43Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ac96895c-095e-491b-bfb0-600935e99f93",
        "parentId" : "8ab2e92a-f602-48fd-9791-9c034cd15044",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Good catch. ",
        "createdAt" : "2020-03-18T08:07:18Z",
        "updatedAt" : "2020-03-18T12:46:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a58b8b64400741795af304d763a8e244b07dcb09",
    "line" : null,
    "diffHunk" : "@@ -198,9 +201,9 @@ class OrderingSpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n     } yield SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n \n   private def mkVariant(as: List[SValue], bs: List[SValue]) =\n-    as.map(SVariant(VariantTypeCon, VariantCon1, _)) ++\n-      as.map(SVariant(VariantTypeCon, VariantCon2, _)) ++\n-      bs.map(SVariant(VariantTypeCon, VariantCon3, _))\n+    as.map(SVariant(VariantTypeCon, VariantCon1, 1, _)) ++"
  },
  {
    "id" : "4358a962-05a9-47ca-9727-fa5ae9878975",
    "prId" : 4808,
    "comments" : [
      {
        "id" : "1e40fd61-c2d1-4fe1-9be6-a568ba69735e",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Remy, stop logging.",
        "createdAt" : "2020-03-04T15:53:07Z",
        "updatedAt" : "2020-03-09T11:33:56Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c04c19b740c0002bf5adf440310b440f2393af8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,431 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import java.util\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, ImmArray, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+import com.digitalasset.daml.lf.value.Value\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import scala.util.Random\n+\n+class OrderingSpec extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  private val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+  implicit def toTypeConName(s: String): Ref.TypeConName =\n+    Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+  implicit def toName(s: String): Ref.Name =\n+    Ref.Name.assertFromString(s)\n+\n+  private val EnumTypeCon: Ref.TypeConName = \"Color\"\n+\n+  private val EnumCon1: Ref.Name = \"Blue\"\n+  private val EnumCon2: Ref.Name = \"Green\"\n+  private val EnumCon3: Ref.Name = \"Red\"\n+\n+  private val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+  private val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+  private val record2Fields = Ref.Name.Array(\"fst\", \"snd\")\n+\n+  private val VariantTypeCon: Ref.TypeConName = \"Either\"\n+  private val VariantCon1: Ref.Name = \"Left\"\n+  private val VariantCon2: Ref.Name = \"Middle\"\n+  private val VariantCon3: Ref.Name = \"Right\"\n+\n+  private val units =\n+    List(SValue.SValue.Unit)\n+  private val bools =\n+    List(SValue.SValue.False, SValue.SValue.True)\n+  private val ints =\n+    List(SInt64(-1L), SInt64(0L), SInt64(1L))\n+  private val decimals =\n+    List(\"-10000.0000000000\", \"0.0000000000\", \"10000.0000000000\")\n+      .map(x => SNumeric(Numeric.assertFromString(x)))\n+  private val numerics =\n+    List(\"-10000.\", \"0.\", \"10000.\").map(SNumeric compose Numeric.assertFromString)\n+  private val texts =\n+    List(\"\"\"a bit of text\"\"\", \"\"\"some other text\"\"\", \"\"\"some other text again\"\"\").map(SText)\n+  private val dates =\n+    List(\"1969-07-21\", \"1970-01-01\", \"2020-02-02\").map(SDate compose Time.Date.assertFromString)\n+  private val timestamps =\n+    List(\n+      \"1969-07-21T02:56:15.000000Z\",\n+      \"1970-01-01T00:00:00.000000Z\",\n+      \"2020-02-02T20:20:02.020000Z\")\n+      .map(STimestamp compose Time.Timestamp.assertFromString)\n+  private val parties =\n+    List(\"alice\", \"bob\", \"carol\").map(SParty compose Ref.Party.assertFromString)\n+  private val absoluteContractId =\n+    List(\"a\", \"b\", \"c\")\n+      .map(x => SContractId(Value.AbsoluteContractId(Ref.ContractIdString.assertFromString(x))))\n+//  private val relativeContractId =\n+//    List(0, 1).map(x => SContractId(Value.RelativeContractId(Value.NodeId(x))))\n+  private val contractIds = absoluteContractId //++ relativeContractId\n+\n+  private val enums = List(EnumCon1, EnumCon2, EnumCon3).map(SEnum(EnumTypeCon, _))\n+\n+  private val struct0 = List(SStruct(Ref.Name.Array.empty, ArrayList()))\n+\n+  private val records0 = List(SRecord(Record0TypeCon, Ref.Name.Array.empty, ArrayList()))\n+\n+  private val builtinTypeReps = List(\n+    Ast.BTUnit,\n+    Ast.BTBool,\n+    Ast.BTInt64,\n+    Ast.BTText,\n+    Ast.BTNumeric,\n+    Ast.BTTimestamp,\n+    Ast.BTDate,\n+    Ast.BTParty,\n+    Ast.BTContractId,\n+    Ast.BTArrow,\n+    Ast.BTOptional,\n+    Ast.BTList,\n+    Ast.BTTextMap,\n+    Ast.BTGenMap,\n+    Ast.BTAny,\n+    Ast.BTTypeRep,\n+    Ast.BTUpdate,\n+    Ast.BTScenario\n+  ).map(bt => STypeRep(Ast.TBuiltin(bt)))\n+\n+  private val typeNatReps = List(\n+    Numeric.Scale.MinValue,\n+    Numeric.Scale.values(10),\n+    Numeric.Scale.MaxValue,\n+  ).map(s => STypeRep(Ast.TNat(s)))\n+\n+  private val typeTyConReps1 = List(\n+    (\"a\", \"a\", \"a\"),\n+    (\"a\", \"a\", \"b\"),\n+    (\"a\", \"b\", \"a\"),\n+    (\"a\", \"b\", \"b\"),\n+    (\"b\", \"a\", \"a\"),\n+    (\"b\", \"a\", \"b\"),\n+    (\"b\", \"b\", \"a\"),\n+    (\"b\", \"b\", \"b\"),\n+  ).map {\n+    case (pkg, mod, name) =>\n+      STypeRep(\n+        Ast.TTyCon(\n+          Ref.Identifier(\n+            Ref.PackageId.assertFromString(pkg),\n+            Ref.QualifiedName(\n+              Ref.DottedName.assertFromString(mod),\n+              Ref.DottedName.assertFromString(name),\n+            ))))\n+  }\n+\n+  private val typeTyConReps2 = {\n+    val names = List(\"a\", \"a.a\", \"a.b\", \"b.a\", \"b.b\").map(Ref.DottedName.assertFromString)\n+    for {\n+      mod <- names\n+      name <- names\n+    } yield STypeRep(Ast.TTyCon(Ref.Identifier(pkgId, Ref.QualifiedName(mod, name))))\n+  }\n+\n+  private val typeTyConReps3 = {\n+    val names = List(\"a\", \"aa\", \"ab\", \"ba\", \"bb\").map(Ref.DottedName.assertFromString)\n+    for {\n+      mod <- names\n+      name <- names\n+    } yield STypeRep(Ast.TTyCon(Ref.Identifier(pkgId, Ref.QualifiedName(mod, name))))\n+  }\n+\n+  private val typeStructReps = List(\n+    ImmArray.empty,\n+    ImmArray(Ref.Name.assertFromString(\"field0\") -> AstUtil.TUnit),\n+    ImmArray(Ref.Name.assertFromString(\"field0\") -> AstUtil.TInt64),\n+    ImmArray(Ref.Name.assertFromString(\"field1\") -> AstUtil.TUnit),\n+    ImmArray(\n+      Ref.Name.assertFromString(\"field1\") -> AstUtil.TUnit,\n+      Ref.Name.assertFromString(\"field2\") -> AstUtil.TUnit,\n+    ),\n+    ImmArray(\n+      Ref.Name.assertFromString(\"field1\") -> AstUtil.TUnit,\n+      Ref.Name.assertFromString(\"field2\") -> AstUtil.TInt64,\n+    ),\n+    ImmArray(\n+      Ref.Name.assertFromString(\"field1\") -> AstUtil.TInt64,\n+      Ref.Name.assertFromString(\"field2\") -> AstUtil.TUnit,\n+    ),\n+    ImmArray(\n+      Ref.Name.assertFromString(\"field1\") -> AstUtil.TUnit,\n+      Ref.Name.assertFromString(\"field3\") -> AstUtil.TUnit,\n+    ),\n+  ).map(t => STypeRep(Ast.TStruct(t)))\n+\n+  private val typeTypeAppRep = {\n+    val types = List(AstUtil.TBool, AstUtil.TInt64)\n+    for {\n+      a <- types\n+      b <- types\n+    } yield STypeRep(Ast.TApp(a, b))\n+  }\n+\n+  private val typeReps =\n+    List(\n+      Ast.TBuiltin(Ast.BTUnit),\n+      Ast.TBuiltin(Ast.BTScenario),\n+      Ast.TTyCon(EnumTypeCon),\n+      Ast.TTyCon(VariantTypeCon),\n+      Ast.TNat(Numeric.Scale.MinValue),\n+      Ast.TNat(Numeric.Scale.MaxValue),\n+      Ast.TStruct(ImmArray.empty),\n+      Ast.TStruct(ImmArray(Ref.Name.assertFromString(\"field\") -> AstUtil.TUnit)),\n+      Ast.TApp(Ast.TBuiltin(Ast.BTArrow), Ast.TBuiltin(Ast.BTUnit)),\n+      Ast.TApp(\n+        Ast.TApp(Ast.TBuiltin(Ast.BTArrow), Ast.TBuiltin(Ast.BTUnit)),\n+        Ast.TBuiltin(Ast.BTUnit)),\n+    ).map(STypeRep)\n+\n+  private def mkRecord2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n+\n+  private def mkVariant(as: List[SValue], bs: List[SValue]) =\n+    as.map(SVariant(VariantTypeCon, VariantCon1, _)) ++\n+      as.map(SVariant(VariantTypeCon, VariantCon2, _)) ++\n+      bs.map(SVariant(VariantTypeCon, VariantCon3, _))\n+\n+  private def mkStruct2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SStruct(record2Fields, ArrayList(x, y))\n+\n+  @tailrec\n+  private def mkList(\n+      values: List[SValue],\n+      i: Int,\n+      l0: List[List[SValue]] = List.empty): List[List[SValue]] =\n+    if (i <= 0)\n+      l0\n+    else {\n+      val l = for {\n+        h <- values\n+        t <- l0\n+      } yield h :: t\n+      mkList(values, i - 1, List.empty +: l)\n+    }\n+\n+  private def lists(atLeast3Values: List[SValue]) = {\n+    val r = mkList(atLeast3Values.take(3), 4)\n+    assert(r.length == 40)\n+    r\n+  }\n+\n+  private def optLists(atLeast3Values: List[SValue]) = {\n+    val r =\n+      mkList(SOptional(Option.empty) :: atLeast3Values.take(3).map(x => SOptional(Some(x))), 4)\n+    assert(r.length == 85)\n+    r\n+  }\n+\n+  private def mkOptionals(values: List[SValue]): List[SValue] =\n+    SOptional(None) +: values.map(x => SOptional(Some(x)))\n+\n+  private def mkLists(lists: List[List[SValue]]): List[SValue] =\n+    lists.map(xs => SList(FrontStack(xs)))\n+\n+  private def mkTextMaps(lists: List[List[SValue]]): List[SValue] = {\n+    val keys = List(\"a\", \"b\", \"c\")\n+    lists.map(xs => STextMap(HashMap(keys zip xs: _*)))\n+  }\n+\n+//  private def mkGenMaps(keys: List[SValue], lists: List[List[SValue]]): List[SValue] = {\n+//    val skeys = keys.map(SGenMap.Key(_))\n+//    lists.map(xs => SGenMap(InsertOrdMap(skeys zip xs: _*)))\n+//  }\n+\n+  private def anys = {\n+    val wrappedInts = ints.map(SAny(AstUtil.TInt64, _))\n+    val wrappedAnyInts = wrappedInts.map(SAny(AstUtil.TAny, _))\n+    val wrappedIntOptional = ints.map(SAny(AstUtil.TOptional(AstUtil.TInt64), _))\n+\n+    wrappedInts ++ wrappedAnyInts ++ wrappedIntOptional\n+  }\n+\n+  private val comparableValues: TableFor1[TableFor1[SValue]] = Table(\n+    \"comparable values\",\n+    // Atomic values\n+    Table(\"Unit\", units: _*),\n+    Table(\"Bool\", bools: _*),\n+    Table(\"Int64\", ints: _*),\n+    Table(\"Decimal\", decimals: _*),\n+    Table(\"Numeric with scale 0\", numerics: _*),\n+    Table(\"Text\", texts: _*),\n+    Table(\"Date\", dates: _*),\n+    Table(\"Timestamp\", timestamps: _*),\n+    Table(\"Party\", parties: _*),\n+    Table(\"ContractId\", contractIds: _*),\n+    Table(\"Enum\", enums: _*),\n+    Table(\"Record of size 0\", records0: _*),\n+    Table(\"struct of size 0\", struct0: _*),\n+    Table(\"Representation of builtin types\", builtinTypeReps: _*),\n+    Table(\"Representation of nat types\", typeNatReps: _*),\n+    Table(\"Representation of types constructors (1)\", typeTyConReps1: _*),\n+    Table(\"Representation of types constructors (2)\", typeTyConReps2: _*),\n+    Table(\"Representation of types constructors (3)\", typeTyConReps3: _*),\n+    Table(\"Representation of struct types\", typeStructReps: _*),\n+    Table(\"Representation of type applications\", typeTypeAppRep: _*),\n+    Table(\"Representation of type\", typeReps: _*),\n+    // 1 level nested values\n+    Table(\"Int64 record of size 2\", mkRecord2(ints, ints): _*),\n+    Table(\"Text record of size 2\", mkRecord2(texts, texts): _*),\n+    Table(\"Variant\", mkVariant(texts, texts): _*),\n+    Table(\"Struct of size 2\", mkStruct2(texts, texts): _*),\n+    Table(\"Optional\", mkOptionals(texts): _*),\n+    Table(\"Int64 Lists\", mkLists(lists(ints)): _*),\n+    Table(\"Int64 TextMap\", mkTextMaps(lists(ints)): _*),\n+//    Table(\"genMap_1\", mkGenMaps(ints, lists(ints)): _*),\n+    // 2 level nested values\n+    Table(\"Int64 Option Records of size 2\", mkRecord2(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"Text Option Variants \", mkVariant(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"Text Option Struct\", mkStruct2(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"Text Option Option\", mkOptionals(mkOptionals(texts)): _*),\n+    Table(\"Int64 Option List\", mkLists(optLists(ints)): _*),\n+    Table(\"Int64 Option TextMap\", mkTextMaps(optLists(ints)): _*),\n+//    Table(\"genMap_2\", mkGenMaps(mkOptionals(ints), optLists(ints)): _*),\n+    // any\n+    Table(\"any\", anys: _*),\n+  )\n+\n+  private val lfFunction = SPAP(PBuiltin(SBuiltin.SBAddInt64), ArrayList(SInt64(1)), 2)\n+\n+  private val funs = List(\n+    lfFunction,\n+    SPAP(PClosure(SExpr.SEVar(2), Array()), ArrayList(SValue.SValue.Unit), 2),\n+  )\n+\n+  private def nonEquatableLists(atLeast2InEquatableValues: List[SValue]) = {\n+    val a :: b :: _ = atLeast2InEquatableValues\n+    List(\n+      List(a),\n+      List(b),\n+      List(a, a),\n+      List(b, b),\n+      List(a, b),\n+    )\n+  }\n+\n+  private def nonEquatableAnys = {\n+    val Type0 = AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64)\n+    val wrappedFuns = funs.map(SAny(Type0, _))\n+    val wrappedFunOptional = funs.map(SAny(AstUtil.TOptional(Type0), _))\n+    val wrappedAnyFuns = wrappedFuns.map(SAny(AstUtil.TAny, _))\n+    // add a bit more cases  here\n+    wrappedFuns ++ wrappedFunOptional ++ wrappedAnyFuns\n+  }\n+\n+  val nonComparable: TableFor1[TableFor1[SValue]] =\n+    Table(\n+      \"nonEquatable values\",\n+      Table(\"funs\", funs: _*),\n+      Table(\"token\", SValue.SToken),\n+      Table(\"nat\", SValue.STNat(Numeric.Scale.MinValue), SValue.STNat(Numeric.Scale.MaxValue)),\n+      Table(\"nonEquatable record\", mkRecord2(funs, units) ++ mkRecord2(units, funs): _*),\n+      Table(\"nonEquatable struct\", mkStruct2(funs, units) ++ mkStruct2(units, funs): _*),\n+      Table(\"nonEquatable optional\", funs.map(x => SOptional(Some(x))): _*),\n+      Table(\"nonEquatable list\", mkLists(nonEquatableLists(funs)): _*),\n+      Table(\"nonEquatable textMap\", mkTextMaps(nonEquatableLists(funs)): _*),\n+//      Table(\"nonEquatable genMap\", mkGenMaps(ints, nonEquatableLists(funs)): _*),\n+      Table(\"nonEquatable variant\", mkVariant(funs, funs): _*),\n+      Table(\"nonEquatable any\", nonEquatableAnys: _*),\n+    )\n+\n+  val nonEquatableWithEquatableValues: TableFor2[SValue, SValue] =\n+    Table(\n+      \"nonEquatable values\" -> \"equatable values\",\n+      SOptional(None) ->\n+        SOptional(Some(lfFunction)),\n+      SList(FrontStack.empty) ->\n+        SList(FrontStack(lfFunction)),\n+      STextMap(HashMap.empty) ->\n+        STextMap(HashMap(\"a\" -> lfFunction)),\n+      SGenMap(InsertOrdMap.empty) -> SGenMap(InsertOrdMap(SGenMap.Key(SInt64(0)) -> lfFunction)),\n+      SVariant(VariantTypeCon, VariantCon1, SInt64(0)) ->\n+        SVariant(VariantTypeCon, VariantCon2, lfFunction),\n+      SAny(AstUtil.TInt64, SInt64(1)) ->\n+        SAny(AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64), lfFunction),\n+    )\n+\n+  \"Order.compare\" should {\n+\n+    // In the following tests, we check only well-type equalities\n+\n+    \"be reflexive on comparable values\" in {\n+      forEvery(comparableValues)(atoms =>\n+        forEvery(atoms) { x =>\n+          assert(Ordering.compare(x, x) == 0)\n+      })\n+    }\n+\n+    \"be symmetric on comparable values\" in {\n+      forEvery(comparableValues) { atoms =>\n+        for {\n+          x <- atoms\n+          y <- atoms\n+        } assert(Ordering.compare(x, y).signum == -Ordering.compare(y, x).signum)\n+      }\n+    }\n+\n+    \"be transitive on comparable values\" in {\n+      forEvery(comparableValues) { atoms =>\n+        val rAtoms = Random.shuffle(atoms).take(10)\n+        for {\n+          x <- rAtoms\n+          y <- rAtoms\n+          if Ordering.compare(x, y) <= 0\n+          z <- rAtoms\n+          if Ordering.compare(y, z) <= 0\n+        } assert(Ordering.compare(x, z) <= 0)\n+      }\n+    }\n+\n+    \"agree with equality comparable values\" in {\n+      forEvery(comparableValues) { atoms =>\n+        for {\n+          x <- atoms\n+          y <- atoms\n+        } {\n+          if ((Ordering.compare(x, y) == 0) != Equality.areEqual(x, y))\n+            remy.log(x -> y -> (Ordering.compare(x, y) == 0) -> Equality.areEqual(x, y))\n+          assert((Ordering.compare(x, y) == 0) == Equality.areEqual(x, y))\n+        }\n+      }\n+    }\n+\n+    \"preserves the specified order\" in {\n+      forEvery(comparableValues) { atoms =>\n+        val inputs = atoms.toList\n+        val sorted = new Random(0).shuffle(inputs).sorted(Ordering)\n+        if (!(inputs zip sorted).forall { case (x, y) => Equality.areEqual(x, y) }) {\n+          remy.log(inputs)\n+          remy.log(sorted)"
  },
  {
    "id" : "250b85e8-60ee-472b-926d-40aa7b637994",
    "prId" : 4808,
    "comments" : [
      {
        "id" : "7ee75ee6-345b-4bf1-ad2a-d8c72593f4c3",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Delete. ðŸš®",
        "createdAt" : "2020-03-04T15:53:24Z",
        "updatedAt" : "2020-03-09T11:33:56Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c04c19b740c0002bf5adf440310b440f2393af8",
    "line" : 74,
    "diffHunk" : "@@ -0,0 +1,431 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import java.util\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, ImmArray, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+import com.digitalasset.daml.lf.value.Value\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import scala.util.Random\n+\n+class OrderingSpec extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  private val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+  implicit def toTypeConName(s: String): Ref.TypeConName =\n+    Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+  implicit def toName(s: String): Ref.Name =\n+    Ref.Name.assertFromString(s)\n+\n+  private val EnumTypeCon: Ref.TypeConName = \"Color\"\n+\n+  private val EnumCon1: Ref.Name = \"Blue\"\n+  private val EnumCon2: Ref.Name = \"Green\"\n+  private val EnumCon3: Ref.Name = \"Red\"\n+\n+  private val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+  private val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+  private val record2Fields = Ref.Name.Array(\"fst\", \"snd\")\n+\n+  private val VariantTypeCon: Ref.TypeConName = \"Either\"\n+  private val VariantCon1: Ref.Name = \"Left\"\n+  private val VariantCon2: Ref.Name = \"Middle\"\n+  private val VariantCon3: Ref.Name = \"Right\"\n+\n+  private val units =\n+    List(SValue.SValue.Unit)\n+  private val bools =\n+    List(SValue.SValue.False, SValue.SValue.True)\n+  private val ints =\n+    List(SInt64(-1L), SInt64(0L), SInt64(1L))\n+  private val decimals =\n+    List(\"-10000.0000000000\", \"0.0000000000\", \"10000.0000000000\")\n+      .map(x => SNumeric(Numeric.assertFromString(x)))\n+  private val numerics =\n+    List(\"-10000.\", \"0.\", \"10000.\").map(SNumeric compose Numeric.assertFromString)\n+  private val texts =\n+    List(\"\"\"a bit of text\"\"\", \"\"\"some other text\"\"\", \"\"\"some other text again\"\"\").map(SText)\n+  private val dates =\n+    List(\"1969-07-21\", \"1970-01-01\", \"2020-02-02\").map(SDate compose Time.Date.assertFromString)\n+  private val timestamps =\n+    List(\n+      \"1969-07-21T02:56:15.000000Z\",\n+      \"1970-01-01T00:00:00.000000Z\",\n+      \"2020-02-02T20:20:02.020000Z\")\n+      .map(STimestamp compose Time.Timestamp.assertFromString)\n+  private val parties =\n+    List(\"alice\", \"bob\", \"carol\").map(SParty compose Ref.Party.assertFromString)\n+  private val absoluteContractId =\n+    List(\"a\", \"b\", \"c\")\n+      .map(x => SContractId(Value.AbsoluteContractId(Ref.ContractIdString.assertFromString(x))))\n+//  private val relativeContractId =\n+//    List(0, 1).map(x => SContractId(Value.RelativeContractId(Value.NodeId(x))))"
  }
]