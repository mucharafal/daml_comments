[
  {
    "id" : "91b6cc1b-196b-4f2c-a17b-6c44f58d7f90",
    "prId" : 6918,
    "comments" : [
      {
        "id" : "bd96b15d-6003-4de1-8351-969f62ed6da0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The title of the test is a lambda with 3 params whereas this lambda has only 2 params. Something got out of sync here.",
        "createdAt" : "2020-07-30T14:40:25Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "af3b3b6a-1b88-4520-9e96-a2a97cf1947f",
        "parentId" : "bd96b15d-6003-4de1-8351-969f62ed6da0",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "fixed the title",
        "createdAt" : "2020-08-04T07:54:08Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a92f961786f34509dbaa09fc380a83b8561bc236",
    "line" : 160,
    "diffHunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.speedy\n+\n+import org.scalatest.{Assertion, WordSpec, Matchers}\n+\n+import com.daml.lf.speedy.SExpr._\n+import com.daml.lf.speedy.SValue._\n+import com.daml.lf.speedy.SBuiltin._\n+import com.daml.lf.speedy.Anf.flattenToAnf\n+import com.daml.lf.speedy.Pretty.SExpr._\n+import com.daml.lf.data.Ref._\n+\n+class AnfTest extends WordSpec with Matchers {\n+\n+  \"identity: [\\\\x. x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, arg0)\n+      val expected = original\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"twice: [\\\\f x. f (f x)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, arg1)))\n+      val expected = lam(2, let1(appa(arg0, arg1), appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"thrice: [\\\\f x. f (f (f x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, app(arg0, arg1))))\n+      val expected =\n+        lam(2, let1(appa(arg0, arg1), let1(appa(arg0, stack1), appa(arg0, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"arithmetic non-atomic: [\\\\f x. f (x+1)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, binop(SBAddInt64, arg1, num1)))\n+      val expected = lam(2, let1b2(SBAddInt64, arg1, num1, appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested (4x non-atomic): [\\\\f x. f(x+1) - f(x+2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(\n+          2,\n+          binop(\n+            SBSubInt64,\n+            app(arg0, binop(SBAddInt64, arg1, num1)),\n+            app(arg0, binop(SBAddInt64, arg1, num2))))\n+      val expected =\n+        lam(\n+          2,\n+          let1b2(\n+            SBAddInt64,\n+            arg1,\n+            num1,\n+            let1(\n+              appa(arg0, stack1),\n+              let1b2(\n+                SBAddInt64,\n+                arg1,\n+                num2,\n+                let1(appa(arg0, stack1), binopa(SBSubInt64, stack3, stack1))))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"builtin multi-arg fun: [\\\\g. (g 1) - (g 2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(1, binop(SBSubInt64, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        lam(1, let1(appa(arg1, num1), let1(appa(arg1, num2), binopa(SBSubInt64, stack2, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"unknown multi-arg fun: [\\\\f g. f (g 1) (g 2)]\" should {\n+    \"be transformed to ANF as expected (safely)\" in {\n+      val original =\n+        lam(2, app2(arg0, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        lam(\n+          2,\n+          let1(\n+            appa(arg1, num1),\n+            let1(appa(arg0, stack1), let1(appa(arg1, num2), appa(stack2, stack1)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"fold applied to 3 args\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(3, app3(folde, arg0, arg1, arg2))\n+      val expected = lam(3, appa3(folde, arg0, arg1, arg2))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"fold (over)applied to 4 args\" should {\n+    \"be transformed to ANF as expected (safely)\" in {\n+      val original = lam(4, app4(folde, arg0, arg1, arg2, arg3))\n+      val expected =\n+        lam(\n+          4,\n+          let1(\n+            appa(folde, arg0),\n+            let1(appa(stack1, arg1), let1(appa(stack1, arg2), appa(stack1, arg3)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"error applied to 1 arg\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, SEApp(SEBuiltin(SBError), Array(arg0)))\n+      val expected = lam(1, SEAppAtomicSaturatedBuiltin(SBError, Array(arg0)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"error (over) applied to 2 arg\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, SEApp(SEBuiltin(SBError), Array(arg0, arg1)))\n+      val expected =\n+        lam(2, SELet1Builtin(SBError, Array(arg0), appa(stack1, arg1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"case expression: [\\\\a b c. if a then b else c]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(3, ite(arg0, arg1, arg2))\n+      val expected = lam(3, itea(arg0, arg1, arg2))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"non-atomic in branch: [\\\\f x. if x==0 then 1 else f (div(1,x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(2, ite(binop(SBEqual, arg1, num0), num1, app(arg0, binop(SBDivInt64, num1, arg1))))\n+      val expected =\n+        lam(\n+          2,\n+          let1b2(\n+            SBEqual,\n+            arg1,\n+            num0,\n+            itea(stack1, num1, let1b2(SBDivInt64, num1, arg1, appa(arg0, stack1)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested lambda: [\\\\f g x. g (\\\\y. f (f y)) x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(2, app(arg1, clo1(arg0, 1, app(free0, app(free0, arg0)))))"
  },
  {
    "id" : "e86dc20b-75a9-4575-b78a-41cb48c0bccc",
    "prId" : 6918,
    "comments" : [
      {
        "id" : "b15a6fc6-ce94-4072-ab01-1115f35e2476",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is this the test for the issue @cocreature raised?",
        "createdAt" : "2020-07-30T14:42:08Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "888ef781-6562-48ef-842f-bad1e285438d",
        "parentId" : "b15a6fc6-ce94-4072-ab01-1115f35e2476",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "yes",
        "createdAt" : "2020-08-04T07:54:16Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a92f961786f34509dbaa09fc380a83b8561bc236",
    "line" : 125,
    "diffHunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.speedy\n+\n+import org.scalatest.{Assertion, WordSpec, Matchers}\n+\n+import com.daml.lf.speedy.SExpr._\n+import com.daml.lf.speedy.SValue._\n+import com.daml.lf.speedy.SBuiltin._\n+import com.daml.lf.speedy.Anf.flattenToAnf\n+import com.daml.lf.speedy.Pretty.SExpr._\n+import com.daml.lf.data.Ref._\n+\n+class AnfTest extends WordSpec with Matchers {\n+\n+  \"identity: [\\\\x. x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, arg0)\n+      val expected = original\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"twice: [\\\\f x. f (f x)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, arg1)))\n+      val expected = lam(2, let1(appa(arg0, arg1), appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"thrice: [\\\\f x. f (f (f x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, app(arg0, arg1))))\n+      val expected =\n+        lam(2, let1(appa(arg0, arg1), let1(appa(arg0, stack1), appa(arg0, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"arithmetic non-atomic: [\\\\f x. f (x+1)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, binop(SBAddInt64, arg1, num1)))\n+      val expected = lam(2, let1b2(SBAddInt64, arg1, num1, appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested (4x non-atomic): [\\\\f x. f(x+1) - f(x+2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(\n+          2,\n+          binop(\n+            SBSubInt64,\n+            app(arg0, binop(SBAddInt64, arg1, num1)),\n+            app(arg0, binop(SBAddInt64, arg1, num2))))\n+      val expected =\n+        lam(\n+          2,\n+          let1b2(\n+            SBAddInt64,\n+            arg1,\n+            num1,\n+            let1(\n+              appa(arg0, stack1),\n+              let1b2(\n+                SBAddInt64,\n+                arg1,\n+                num2,\n+                let1(appa(arg0, stack1), binopa(SBSubInt64, stack3, stack1))))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"builtin multi-arg fun: [\\\\g. (g 1) - (g 2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(1, binop(SBSubInt64, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        lam(1, let1(appa(arg1, num1), let1(appa(arg1, num2), binopa(SBSubInt64, stack2, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"unknown multi-arg fun: [\\\\f g. f (g 1) (g 2)]\" should {\n+    \"be transformed to ANF as expected (safely)\" in {\n+      val original =\n+        lam(2, app2(arg0, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        lam(\n+          2,\n+          let1(\n+            appa(arg1, num1),\n+            let1(appa(arg0, stack1), let1(appa(arg1, num2), appa(stack2, stack1)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"fold applied to 3 args\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(3, app3(folde, arg0, arg1, arg2))\n+      val expected = lam(3, appa3(folde, arg0, arg1, arg2))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"fold (over)applied to 4 args\" should {\n+    \"be transformed to ANF as expected (safely)\" in {\n+      val original = lam(4, app4(folde, arg0, arg1, arg2, arg3))\n+      val expected =\n+        lam(\n+          4,\n+          let1(\n+            appa(folde, arg0),\n+            let1(appa(stack1, arg1), let1(appa(stack1, arg2), appa(stack1, arg3)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"error applied to 1 arg\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, SEApp(SEBuiltin(SBError), Array(arg0)))\n+      val expected = lam(1, SEAppAtomicSaturatedBuiltin(SBError, Array(arg0)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"error (over) applied to 2 arg\" should {"
  },
  {
    "id" : "6b254399-3224-462d-8da0-87c0b349897c",
    "prId" : 6918,
    "comments" : [
      {
        "id" : "e80e6123-f0ed-4dbe-ad0d-9e5122a2ec37",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This test says we're transforming\r\n```\r\nf (g 1) g(2)\r\n```\r\ninto\r\n```\r\nlet x = g 1 in\r\nlet y = f x in\r\nlet z = g 2 in\r\ny z\r\n```\r\ndoesn't it? To me this looks exactly like the cascade of `let`s and single argument applications we want to avoid.",
        "createdAt" : "2020-07-30T15:04:06Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "396542f5-10d7-4edf-956e-f2476b64d5e6",
        "parentId" : "e80e6123-f0ed-4dbe-ad0d-9e5122a2ec37",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Oh sorry. That is very embarrassing. I had the wrong version of the transform switched on.\r\nWhat is worse. When I switch to the transform we intend, it crashes in just the same was as attempt #2.",
        "createdAt" : "2020-07-30T15:20:14Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4eb21150-b9c4-402e-8d00-fae9fa592b0b",
        "parentId" : "e80e6123-f0ed-4dbe-ad0d-9e5122a2ec37",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I need to look carefully at what is going on here.",
        "createdAt" : "2020-07-30T15:21:07Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "49d458bf-0494-4c1a-ad5d-9d61805f934d",
        "parentId" : "e80e6123-f0ed-4dbe-ad0d-9e5122a2ec37",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "ok, so the new transform, which avoids the transform to a cascade of single-apps in now switched on\r\nand the AnfTests are updated to show this",
        "createdAt" : "2020-08-04T07:55:12Z",
        "updatedAt" : "2020-08-12T07:41:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a92f961786f34509dbaa09fc380a83b8561bc236",
    "line" : 87,
    "diffHunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.speedy\n+\n+import org.scalatest.{Assertion, WordSpec, Matchers}\n+\n+import com.daml.lf.speedy.SExpr._\n+import com.daml.lf.speedy.SValue._\n+import com.daml.lf.speedy.SBuiltin._\n+import com.daml.lf.speedy.Anf.flattenToAnf\n+import com.daml.lf.speedy.Pretty.SExpr._\n+import com.daml.lf.data.Ref._\n+\n+class AnfTest extends WordSpec with Matchers {\n+\n+  \"identity: [\\\\x. x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, arg0)\n+      val expected = original\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"twice: [\\\\f x. f (f x)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, arg1)))\n+      val expected = lam(2, let1(appa(arg0, arg1), appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"thrice: [\\\\f x. f (f (f x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, app(arg0, arg1))))\n+      val expected =\n+        lam(2, let1(appa(arg0, arg1), let1(appa(arg0, stack1), appa(arg0, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"arithmetic non-atomic: [\\\\f x. f (x+1)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, binop(SBAddInt64, arg1, num1)))\n+      val expected = lam(2, let1b2(SBAddInt64, arg1, num1, appa(arg0, stack1)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested (4x non-atomic): [\\\\f x. f(x+1) - f(x+2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(\n+          2,\n+          binop(\n+            SBSubInt64,\n+            app(arg0, binop(SBAddInt64, arg1, num1)),\n+            app(arg0, binop(SBAddInt64, arg1, num2))))\n+      val expected =\n+        lam(\n+          2,\n+          let1b2(\n+            SBAddInt64,\n+            arg1,\n+            num1,\n+            let1(\n+              appa(arg0, stack1),\n+              let1b2(\n+                SBAddInt64,\n+                arg1,\n+                num2,\n+                let1(appa(arg0, stack1), binopa(SBSubInt64, stack3, stack1))))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"builtin multi-arg fun: [\\\\g. (g 1) - (g 2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(1, binop(SBSubInt64, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        lam(1, let1(appa(arg1, num1), let1(appa(arg1, num2), binopa(SBSubInt64, stack2, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"unknown multi-arg fun: [\\\\f g. f (g 1) (g 2)]\" should {"
  },
  {
    "id" : "7a068bfb-396e-43ac-a0d6-def171d17e2e",
    "prId" : 6562,
    "comments" : [
      {
        "id" : "9f70744b-0e7e-4447-bdcf-eddc01f021f1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please have a test case for the expression mentioned in https://github.com/digital-asset/daml/issues/6535 as well?",
        "createdAt" : "2020-07-01T18:58:11Z",
        "updatedAt" : "2020-07-02T07:27:39Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "016c0667-b14b-41c1-bc33-1a7e7c5fdc72",
        "parentId" : "9f70744b-0e7e-4447-bdcf-eddc01f021f1",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done. turns out we never did add redundant lets in this example",
        "createdAt" : "2020-07-02T07:31:16Z",
        "updatedAt" : "2020-07-02T07:31:17Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ca69a9ff42f50246a7439214e6ddcfd720da0fe",
    "line" : 126,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.speedy\n+\n+import org.scalatest.{Assertion, WordSpec, Matchers}\n+\n+import com.daml.lf.speedy.SExpr._\n+import com.daml.lf.speedy.SValue._\n+import com.daml.lf.speedy.SBuiltin._\n+import com.daml.lf.speedy.Anf.flattenToAnf\n+import com.daml.lf.speedy.Pretty.SExpr._\n+import com.daml.lf.data.Ref._\n+\n+class AnfTest extends WordSpec with Matchers {\n+\n+  \"identity: [\\\\x. x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(1, arg0)\n+      val expected = AExpr(original)\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"twice: [\\\\f x. f (f x)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, arg1)))\n+      val expected = AExpr(lam(2, let1(appa(arg0, arg1), appa(arg0, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"thrice: [\\\\f x. f (f (f x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, app(arg0, app(arg0, arg1))))\n+      val expected =\n+        AExpr(lam(2, let1(appa(arg0, arg1), let1(appa(arg0, stack1), appa(arg0, stack1)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"arithmetic non-atomic: [\\\\f x. f (x+1)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(2, app(arg0, binop(SBAddInt64, arg1, num1)))\n+      val expected = AExpr(lam(2, let1b2(SBAddInt64, arg1, num1, appa(arg0, stack1))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested (4x non-atomic): [\\\\f x. f(x+1) - f(x+2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(\n+          2,\n+          binop(\n+            SBSubInt64,\n+            app(arg0, binop(SBAddInt64, arg1, num1)),\n+            app(arg0, binop(SBAddInt64, arg1, num2))))\n+      val expected =\n+        AExpr(\n+          lam(\n+            2,\n+            let1b2(\n+              SBAddInt64,\n+              arg1,\n+              num1,\n+              let1(\n+                appa(arg0, stack1),\n+                let1b2(\n+                  SBAddInt64,\n+                  arg1,\n+                  num2,\n+                  let1(appa(arg0, stack1), binopa(SBSubInt64, stack3, stack1)))))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"multi-arg fun: [\\\\f g. f (g 1) (g 2)]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(2, app2(arg0, app(arg1, num1), app(arg1, num2)))\n+      val expected =\n+        AExpr(lam(2, let1(appa(arg1, num1), let1(appa(arg1, num2), app2a(arg0, stack2, stack1)))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"case expression: [\\\\a b c. if a then b else c]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original = lam(3, ite(arg0, arg1, arg2))\n+      val expected = AExpr(lam(3, itea(arg0, arg1, arg2)))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"non-atomic in branch: [\\\\f x. if x==0 then 1 else f (div(1,x))]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(2, ite(binop(SBEqual, arg1, num0), num1, app(arg0, binop(SBDivInt64, num1, arg1))))\n+      val expected =\n+        AExpr(\n+          lam(\n+            2,\n+            let1b2(\n+              SBEqual,\n+              arg1,\n+              num0,\n+              itea(stack1, num1, let1b2(SBDivInt64, num1, arg1, appa(arg0, stack1))))))\n+      testTransform(original, expected)\n+    }\n+  }\n+\n+  \"nested lambda: [\\\\f g x. g (\\\\y. f (f y)) x]\" should {\n+    \"be transformed to ANF as expected\" in {\n+      val original =\n+        lam(3, app2(arg1, clo1(arg0, 1, app(free0, app(free0, arg0))), arg2))\n+      val expected =\n+        AExpr(\n+          lam(\n+            3,\n+            let1(\n+              clo1(arg0, 1, let1(appa(free0, arg0), appa(free0, stack1))),\n+              app2a(arg1, stack1, arg2))))\n+      testTransform(original, expected)\n+    }\n+  }"
  }
]