[
  {
    "id" : "c86f61c8-fb5f-4069-8c3e-2d27f9e3ba58",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "9ac24e22-405c-4d01-bd4a-dc67d0e7f1d5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Shouldn't this be in scope only for `pkg1`, like for `pkg2` below?",
        "createdAt" : "2020-09-03T12:40:55Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c869365-7f0d-42b5-a398-99ecb5877a9e",
        "parentId" : "9ac24e22-405c-4d01-bd4a-dc67d0e7f1d5",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "This is used also inside the definition of the test case, everywhere we have `t\"...\"` and `e\"...\"`.\r\nI put this in the scope of `pkg1`, and copy past in the scope of the test cases definition to make it more obvious. ",
        "createdAt" : "2020-09-04T10:43:42Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,642 @@\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] ="
  },
  {
    "id" : "30f15902-d88f-4e19-b581-1958cdab9834",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "99666541-0376-432c-a842-b263dc013ee0",
        "parentId" : null,
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "```suggestion\r\n              e\"type_rep @<field1: Unit, field2: Unit>\",\r\n              e\"type_rep @<field1: Unit, field2: Int64>\",\r\n              e\"type_rep @<field1: Int64, field2: Unit>\",\r\n              e\"type_rep @<field1: Int64, field2: Int64>\",\r\n              e\"type_rep @<field1: Unit, field3: Unit>\",\r\n```",
        "createdAt" : "2020-09-04T09:47:53Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\","
  },
  {
    "id" : "17436f03-f5e5-47b7-ba13-bc542cb139b1",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "d8d051dc-c2a0-49c2-8588-e9ef1fa792f7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does this line have a purpose (anymore)?",
        "createdAt" : "2020-09-04T09:48:05Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ebe1bc7-4926-4642-92c0-7f86c83b0009",
        "parentId" : "d8d051dc-c2a0-49c2-8588-e9ef1fa792f7",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped.",
        "createdAt" : "2020-09-04T10:46:55Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),"
  },
  {
    "id" : "56a96610-aecf-430d-a590-5483ae31719a",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "b52cf173-0a0e-45c6-b99f-3190a112a14c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "May I suggest to start module and types names with capital letters here?",
        "createdAt" : "2020-09-04T09:49:31Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "31f0f77c-bc7c-461b-913a-14b2dcc798cb",
        "parentId" : "b52cf173-0a0e-45c6-b99f-3190a112a14c",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done.",
        "createdAt" : "2020-09-04T10:46:14Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {"
  },
  {
    "id" : "cde99d4b-b253-42b0-b8b5-88be59a3b039",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "b31f32f9-8c3c-406f-85c2-a3ef7bbbfb4a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Doesn't `type_rep` only work for closed types of kind star?",
        "createdAt" : "2020-09-04T09:50:08Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cbd34706-9fbb-4760-b08f-bcbd9c66ebb3",
        "parentId" : "b31f32f9-8c3c-406f-85c2-a3ef7bbbfb4a",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I tried to refactor, to have only well type expressions.",
        "createdAt" : "2020-09-04T11:33:43Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\","
  },
  {
    "id" : "96497c46-3e99-462f-90a0-3874324784d9",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "acf64951-f20d-4a0c-bf83-585bb25bf654",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n              e\"\"\" Some @Text \"B\" \"\"\",\r\n```\r\nto make the intent more obvious.",
        "createdAt" : "2020-09-04T09:52:09Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Int64)\",\n+              e\"type_rep @(Option Unit)\",\n+              e\"type_rep @(Option Int64)\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Scenario\",\n+              e\"type_rep @a:a\",\n+              e\"type_rep @b:b\",\n+              e\"type_rep @5\",\n+              e\"type_rep @20\",\n+              e\"type_rep @<field: Unit>\",\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Unit Unit)\",\n+            ),\n+          // 1 level nested values\n+          t\"Mod:Tuple Int64 Int64\" ->\n+            List(\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 1}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 1}\"\n+            ),\n+          t\"Mod:Either Text Int64\" -> List(\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 -1 \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 1 \"\"\",\n+          ),\n+          t\"<fst: Int64, snd: Int64>\" ->\n+            List(\n+              e\"<fst = 0, snd = 0>\",\n+              e\"<fst = 0, snd = 1>\",\n+              e\"<fst = 1, snd = 0>\",\n+              e\"<fst = 1, snd = 1>\"\n+            ),\n+          t\"Optional Text\" ->\n+            List(\n+              e\"\"\" None @Text \"\"\",\n+              e\"\"\" Some @Text \"A\" \"\"\",\n+              e\"\"\" Some @Text \"AA\" \"\"\","
  },
  {
    "id" : "e83779a1-71b6-4b23-acf2-859ddeba6726",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "73f71257-f2ee-4041-a9d5-bcb18d824f58",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64 \"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\r\n              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\r\n```",
        "createdAt" : "2020-09-04T09:53:02Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Int64)\",\n+              e\"type_rep @(Option Unit)\",\n+              e\"type_rep @(Option Int64)\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Scenario\",\n+              e\"type_rep @a:a\",\n+              e\"type_rep @b:b\",\n+              e\"type_rep @5\",\n+              e\"type_rep @20\",\n+              e\"type_rep @<field: Unit>\",\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Unit Unit)\",\n+            ),\n+          // 1 level nested values\n+          t\"Mod:Tuple Int64 Int64\" ->\n+            List(\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 1}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 1}\"\n+            ),\n+          t\"Mod:Either Text Int64\" -> List(\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 -1 \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 1 \"\"\",\n+          ),\n+          t\"<fst: Int64, snd: Int64>\" ->\n+            List(\n+              e\"<fst = 0, snd = 0>\",\n+              e\"<fst = 0, snd = 1>\",\n+              e\"<fst = 1, snd = 0>\",\n+              e\"<fst = 1, snd = 1>\"\n+            ),\n+          t\"Optional Text\" ->\n+            List(\n+              e\"\"\" None @Text \"\"\",\n+              e\"\"\" Some @Text \"A\" \"\"\",\n+              e\"\"\" Some @Text \"AA\" \"\"\",\n+            ),\n+          t\"List Int64\" ->\n+            List(\n+              e\"Nil @Int64\",\n+              e\"Cons @Int64 [0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,1,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,1] (Nil @Int64)\",\n+            ),\n+          t\"TextMap Int64\" ->\n+            List(\n+              e\"TEXTMAP_EMPTY @Int64\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\","
  },
  {
    "id" : "98e3126d-7005-4c9f-87ac-e89d811a94ea",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "dab1a6b7-315d-4edf-89d9-f9b3da6daaf7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_INSERT @Int64 \"c\" 3 (TEXTMAP_EMPTY @Int64)))\"\"\",\r\n              e\"\"\"TEXTMAP_INSERT @Int64 \"b\" 1 (TEXTMAP_EMPTY @Int64)\"\"\",\r\n```",
        "createdAt" : "2020-09-04T09:53:59Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : 245,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Int64)\",\n+              e\"type_rep @(Option Unit)\",\n+              e\"type_rep @(Option Int64)\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Scenario\",\n+              e\"type_rep @a:a\",\n+              e\"type_rep @b:b\",\n+              e\"type_rep @5\",\n+              e\"type_rep @20\",\n+              e\"type_rep @<field: Unit>\",\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Unit Unit)\",\n+            ),\n+          // 1 level nested values\n+          t\"Mod:Tuple Int64 Int64\" ->\n+            List(\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 1}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 1}\"\n+            ),\n+          t\"Mod:Either Text Int64\" -> List(\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 -1 \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 1 \"\"\",\n+          ),\n+          t\"<fst: Int64, snd: Int64>\" ->\n+            List(\n+              e\"<fst = 0, snd = 0>\",\n+              e\"<fst = 0, snd = 1>\",\n+              e\"<fst = 1, snd = 0>\",\n+              e\"<fst = 1, snd = 1>\"\n+            ),\n+          t\"Optional Text\" ->\n+            List(\n+              e\"\"\" None @Text \"\"\",\n+              e\"\"\" Some @Text \"A\" \"\"\",\n+              e\"\"\" Some @Text \"AA\" \"\"\",\n+            ),\n+          t\"List Int64\" ->\n+            List(\n+              e\"Nil @Int64\",\n+              e\"Cons @Int64 [0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,1,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,1] (Nil @Int64)\",\n+            ),\n+          t\"TextMap Int64\" ->\n+            List(\n+              e\"TEXTMAP_EMPTY @Int64\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_INSERT @Int64 \"c\" 3 (TEXTMAP_EMPTY @Int64)))\"\"\","
  },
  {
    "id" : "6a96bfce-c28e-4af7-afc4-86d1e07498ed",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "ed0379ce-a54f-4912-a07a-4323cca13956",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Same suggestions as above.\r\n\r\nAs a more general question, could we make `TextMap v` just be `GenMap Text v` in our implementation?",
        "createdAt" : "2020-09-04T09:55:31Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "91e3f4c5-90c9-4ebe-901c-57284e422b18",
        "parentId" : "ed0379ce-a54f-4912-a07a-4323cca13956",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "probably we could try to factorize that.\r\nNote, we still have to dynamically preserve the type since the conversion to the external world does not know the type (cf. `SValue.toValue`). ",
        "createdAt" : "2020-09-04T11:38:00Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : 257,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Int64)\",\n+              e\"type_rep @(Option Unit)\",\n+              e\"type_rep @(Option Int64)\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Scenario\",\n+              e\"type_rep @a:a\",\n+              e\"type_rep @b:b\",\n+              e\"type_rep @5\",\n+              e\"type_rep @20\",\n+              e\"type_rep @<field: Unit>\",\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Unit Unit)\",\n+            ),\n+          // 1 level nested values\n+          t\"Mod:Tuple Int64 Int64\" ->\n+            List(\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 1}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 1}\"\n+            ),\n+          t\"Mod:Either Text Int64\" -> List(\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 -1 \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 1 \"\"\",\n+          ),\n+          t\"<fst: Int64, snd: Int64>\" ->\n+            List(\n+              e\"<fst = 0, snd = 0>\",\n+              e\"<fst = 0, snd = 1>\",\n+              e\"<fst = 1, snd = 0>\",\n+              e\"<fst = 1, snd = 1>\"\n+            ),\n+          t\"Optional Text\" ->\n+            List(\n+              e\"\"\" None @Text \"\"\",\n+              e\"\"\" Some @Text \"A\" \"\"\",\n+              e\"\"\" Some @Text \"AA\" \"\"\",\n+            ),\n+          t\"List Int64\" ->\n+            List(\n+              e\"Nil @Int64\",\n+              e\"Cons @Int64 [0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,1,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,1] (Nil @Int64)\",\n+            ),\n+          t\"TextMap Int64\" ->\n+            List(\n+              e\"TEXTMAP_EMPTY @Int64\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_INSERT @Int64 \"c\" 3 (TEXTMAP_EMPTY @Int64)))\"\"\",\n+            ),\n+          t\"GenMap Text Int64\" ->\n+            List(\n+              e\"GENMAP_EMPTY @Text @Int64\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_EMPTY @Text @Int64)\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_INSERT @Text @Int64\"b\" 1 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_INSERT @Text @Int64\"b\" 2 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_EMPTY @Text @Int64)\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 1 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 2 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 2 (GENMAP_INSERT @Text @Int64 \"c\" 3 (GENMAP_EMPTY @Text @Int64)))\"\"\","
  },
  {
    "id" : "c6cb77b2-6bc4-401d-94c4-a2c5788a0417",
    "prId" : 7314,
    "comments" : [
      {
        "id" : "ea6b6aec-c08f-4b42-ba5b-8066c3d868a3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does `'left` mean this should fail? If so, why?",
        "createdAt" : "2020-09-04T09:59:09Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "317c58e8-55a4-4117-aeff-2013974d4fc1",
        "parentId" : "ea6b6aec-c08f-4b42-ba5b-8066c3d868a3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "`x shouldBe 'right` => `x.isRight shouldBe true`\r\n`x shouldBe 'left` => `x.isLeft shouldBe true`",
        "createdAt" : "2020-09-04T10:36:09Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bf0e83bf-4fe8-41ad-a673-7acf1fd8ed30",
        "parentId" : "ea6b6aec-c08f-4b42-ba5b-8066c3d868a3",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I understand that. But why should comparing `x` to `y` yield a `Left`?",
        "createdAt" : "2020-09-04T11:21:38Z",
        "updatedAt" : "2020-09-04T11:53:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c1fcaee2-ae12-45bd-982a-ca0ee2d74027",
        "parentId" : "ea6b6aec-c08f-4b42-ba5b-8066c3d868a3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "It is indeed broken. I tried to fix it. \r\n\r\nNote the test is about comparison of structs which is broken.\r\nIt is currently `ignore`, I will activate it in #7319 ",
        "createdAt" : "2020-09-04T11:52:33Z",
        "updatedAt" : "2020-09-04T11:53:57Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5a2351b41373e47d9e810b31effd147da0c2f5e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package speedy\n+\n+import com.daml.lf.data.{ImmArray, Ref, Struct}\n+import com.daml.lf.language.Ast\n+import com.daml.lf.speedy.SError.SError\n+import com.daml.lf.speedy.SResult.SResultError\n+import com.daml.lf.testing.parser.ParserParameters\n+import com.daml.lf.value.Value.ContractId\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+class ComparisonSBuiltinTest extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  import com.daml.lf.testing.parser.Implicits.{defaultParserParameters => _, _}\n+\n+  private[this] val pkgId1 = Ref.PackageId.assertFromString(\"-packageId1-\")\n+  private[this] val pkgId2 = Ref.PackageId.assertFromString(\"-packageId2-\")\n+\n+  private[this] implicit val parserParameters: ParserParameters[this.type] =\n+    com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+      defaultPackageId = pkgId1\n+    )\n+\n+  private[this] val pkg1 =\n+    p\"\"\"\n+        module Mod {\n+          variant Either a b = Left : a | Right : b ;\n+          record MyUnit = { };\n+          record Tuple a b = { fst: a, snd: b };\n+          enum Color = Red | Green | Blue;\n+\n+          record @serializable Template = { };\n+ \n+          template (this : Template) =  {\n+             precondition True,\n+             signatories (Nil @Party),\n+             observers (Nil @Party),\n+             agreement \"Agreement for Mod:Template\",\n+             choices { }\n+          };\n+        }\n+\n+        module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+        module b {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+\n+    \"\"\"\n+\n+  private[this] val pkg2 = {\n+\n+    implicit val parserParameters: ParserParameters[this.type] =\n+      com.daml.lf.testing.parser.Implicits.defaultParserParameters.copy(\n+        defaultPackageId = pkgId2\n+      )\n+\n+    p\"\"\"\n+         module a {\n+          enum a = ;\n+          enum b = ;\n+        }\n+\n+    \"\"\"\n+  }\n+\n+  private[this] val builtins: TableFor2[Ast.BuiltinFunction, Int => Boolean] = Table(\n+    \"builtin\" -> \"result\",\n+    Ast.BLess -> (_ < 0),\n+    Ast.BLessEq -> (_ <= 0),\n+    Ast.BEqual -> (_ == 0),\n+    Ast.BGreaterEq -> (_ >= 0),\n+    Ast.BGreater -> (_ > 0),\n+  )\n+\n+  \"generic comparison builtins\" should {\n+\n+    \"respects specified order\" in {\n+\n+      val comparableValues: TableFor2[Ast.Type, List[Ast.Expr]] =\n+        Table(\n+          \"type\" -> \"comparable values in order\",\n+          // Atomic values\n+          t\"Unit\" -> List(e\"()\"),\n+          t\"Bool\" -> List(e\"False\", e\"True\"),\n+          t\"Int64\" -> List(e\"-3\", e\"0\", e\"1\"),\n+          t\"Decimal\" -> List(e\"-10000.0000000000\", e\"0.0000000000\", e\"10000.0000000000\"),\n+          t\"Numeric 0\" -> List(e\"-10000.\", e\"0.\", e\"10000.\"),\n+          t\"Text\" -> List(\n+            e\"\"\"\"a bit of text\"\"\"\",\n+            e\"\"\"\"some other text\"\"\"\",\n+            e\"\"\"\"some other text again\"\"\"\"),\n+          t\"Date\" -> List(e\"1969-07-21\", e\"1970-01-01\", e\"2020-02-02\"),\n+          t\"Timestamp\" -> List(\n+            e\"1969-07-21T02:56:15.000000Z\",\n+            e\"1970-01-01T00:00:00.000000Z\",\n+            e\"2020-02-02T20:20:02.020000Z\",\n+          ),\n+          t\"Party\" -> List(e\"'alice'\", e\"'bob'\", e\"'carol'\"),\n+          /// Table(\"ContractId\", contractIds: _*),\n+          t\"Mod:Color\" -> List(e\"Mod:Color:Red\", e\"Mod:Color:Green\", e\"Mod:Color:Blue\"),\n+          t\"Mod:MyUnit\" -> List(e\"Mod:MyUnit {}\"),\n+          // Contract IDs cannot be built from expressions.\n+          // We map at runtime the variables `cid1`, `cid2` and, `cid3` two 3 contract IDs in increasing order.\n+          t\"ContractId Mod:Template\" -> List(e\"cid1\", e\"cid2\", e\"cid3\"),\n+          /// Type Representations\n+          t\"Mod:TypRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Bool\",\n+              e\"type_rep @Int64\",\n+              e\"type_rep @Text\",\n+              e\"type_rep @Numeric\",\n+              e\"type_rep @Timestamp\",\n+              e\"type_rep @Date\",\n+              e\"type_rep @Party\",\n+              e\"type_rep @ContractId\",\n+              e\"type_rep @Arrow\",\n+              e\"type_rep @Option\",\n+              e\"type_rep @List\",\n+              e\"type_rep @TextMap\",\n+              e\"type_rep @GenMap\",\n+              e\"type_rep @Any\",\n+              e\"type_rep @TypeRep\",\n+              e\"type_rep @Update\",\n+              e\"type_rep @Scenario\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @0\",\n+              e\"type_rep @10\",\n+              e\"type_rep @37\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @'-packageId1-':a:a\",\n+              e\"type_rep @'-packageId1-':a:b\",\n+              e\"type_rep @'-packageId1-':b:a\",\n+              e\"type_rep @'-packageId1-':b:b\",\n+              e\"type_rep @'-packageId2-':a:a\",\n+              e\"type_rep @'-packageId2-':a:b\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @<field0: Unit>\",\n+              e\"type_rep @<field0: Int64>\",\n+              e\"type_rep @<field1: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Unit>\",\n+              e\"type_rep @<field1: Unit, filed2: Int64>\",\n+              e\"type_rep @<field1: Int64, filed2: Unit>\",\n+              e\"type_rep @<field1: Int64, filed2: Int64>\",\n+              e\"type_rep @<field1: Unit, filed3: Unit>\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Int64)\",\n+              e\"type_rep @(Option Unit)\",\n+              e\"type_rep @(Option Int64)\",\n+            ),\n+          t\"Mod:TypeRep\" ->\n+            List(\n+              e\"type_rep @Unit\",\n+              e\"type_rep @Scenario\",\n+              e\"type_rep @a:a\",\n+              e\"type_rep @b:b\",\n+              e\"type_rep @5\",\n+              e\"type_rep @20\",\n+              e\"type_rep @<field: Unit>\",\n+              e\"type_rep @(Arrow Unit)\",\n+              e\"type_rep @(Arrow Unit Unit)\",\n+            ),\n+          // 1 level nested values\n+          t\"Mod:Tuple Int64 Int64\" ->\n+            List(\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 0, snd = 1}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 0}\",\n+              e\"Mod:Tuple @Int64 @Int64 {fst = 1, snd = 1}\"\n+            ),\n+          t\"Mod:Either Text Int64\" -> List(\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @Text @Int64 \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 -1 \"\"\",\n+            e\"\"\"Mod:Either:Right @Text @Int64 1 \"\"\",\n+          ),\n+          t\"<fst: Int64, snd: Int64>\" ->\n+            List(\n+              e\"<fst = 0, snd = 0>\",\n+              e\"<fst = 0, snd = 1>\",\n+              e\"<fst = 1, snd = 0>\",\n+              e\"<fst = 1, snd = 1>\"\n+            ),\n+          t\"Optional Text\" ->\n+            List(\n+              e\"\"\" None @Text \"\"\",\n+              e\"\"\" Some @Text \"A\" \"\"\",\n+              e\"\"\" Some @Text \"AA\" \"\"\",\n+            ),\n+          t\"List Int64\" ->\n+            List(\n+              e\"Nil @Int64\",\n+              e\"Cons @Int64 [0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,0,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [0,1,1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,0] (Nil @Int64)\",\n+              e\"Cons @Int64 [1,1] (Nil @Int64)\",\n+            ),\n+          t\"TextMap Int64\" ->\n+            List(\n+              e\"TEXTMAP_EMPTY @Int64\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 1 (TEXTMAP_INSERT @Int64\"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_EMPTY @Int64)\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 1 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_EMPTY @Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @Int64 \"a\" 2 (TEXTMAP_INSERT @Int64 \"b\" 2 (TEXTMAP_INSERT @Int64 \"c\" 3 (TEXTMAP_EMPTY @Int64)))\"\"\",\n+            ),\n+          t\"GenMap Text Int64\" ->\n+            List(\n+              e\"GENMAP_EMPTY @Text @Int64\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_EMPTY @Text @Int64)\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_INSERT @Text @Int64\"b\" 1 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 1 (GENMAP_INSERT @Text @Int64\"b\" 2 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_EMPTY @Text @Int64)\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 1 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 2 (GENMAP_EMPTY @Text @Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @Text @Int64 \"a\" 2 (GENMAP_INSERT @Text @Int64 \"b\" 2 (GENMAP_INSERT @Text @Int64 \"c\" 3 (GENMAP_EMPTY @Text @Int64)))\"\"\",\n+            ),\n+          // 2 level nested values\n+          t\"Mod:Tuple (Option Text) (Option Int64)\" ->\n+            List(\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = None @Text, snd = None @Int64}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = None @Text, snd = Some @Int64 0}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = None @Text, snd = Some @Int64 1}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"a\", snd = None @Int64}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"a\", snd = Some @Int64 0}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"a\", snd = Some @Int64 1}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"b\", snd = None @Int64}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"b\", snd = Some @Int64 0}\"\"\",\n+              e\"\"\"Mod:Tuple @Int64 @Int64 {fst = Some @Text \"b\", snd = Some @Int64 1}\"\"\",\n+            ),\n+          t\"Mod:Either (Option Int64) (Option Int64)\" -> List(\n+            e\"\"\"Mod:Either:Left @(Option Text) @(Option Int64) None @Text\"\"\",\n+            e\"\"\"Mod:Either:Left @(Option Text) @(Option Int64) Some @Text \"a\" \"\"\",\n+            e\"\"\"Mod:Either:Left @(Option Text) @(Option Int64) Some @Text \"b\" \"\"\",\n+            e\"\"\"Mod:Either:Right @(Option Int64) @(Option Int64) None @Int64 \"\"\",\n+            e\"\"\"Mod:Either:Right @(Option Int64) @(Option Int64) Some @Int64 42 \"\"\",\n+            e\"\"\"Mod:Either:Right @(Option Int64) @(Option Int64) Some @Int64 43 \"\"\",\n+          ),\n+          t\"<fst: Option Text, snd: Option Int64>\" ->\n+            List(\n+              e\"\"\"<fst = None @Text, snd = None @Int64>\"\"\",\n+              e\"\"\"<fst = None @Text, snd = Some @Int64 0>\"\"\",\n+              e\"\"\"<fst = None @Text, snd = Some @Int64 1>\"\"\",\n+              e\"\"\"<fst = Some @Text \"a\", snd = None @Int64>\"\"\",\n+              e\"\"\"<fst = Some @Text \"a\", snd = Some @Int64 0>\"\"\",\n+              e\"\"\"<fst = Some @Text \"a\", snd = Some @Int64 1>\"\"\",\n+              e\"\"\"<fst = Some @Text \"b\", snd = None @Int64>\"\"\",\n+              e\"\"\"<fst = Some @Text \"b\", snd = Some @Int64 0>\"\"\",\n+              e\"\"\"<fst = Some @Text \"b\", snd = Some @Int64 1>\"\"\",\n+            ),\n+          t\"Option (Option Int64)\" ->\n+            List(\n+              e\"None @(Option Int64)\",\n+              e\"Some @(Option Int64) (None @Int64)\",\n+              e\"Some @(Option Int64) (Some @Int64 0)\",\n+              e\"Some @(Option Int64) (Some @Int64 1)\",\n+            ),\n+          t\"List (Option Int64)\" -> List(\n+            e\"Nil @(Option Int64)\",\n+            e\"Cons @(Option Int64) [None @Int64] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [None @Int64, None @Int64] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [None @Int64, None @Int64, Some @Int64 0] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [None @Int64, Some @Int64 0, Some @Int64 0] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [None @Int64, Some @Int64 1, Some @Int64 0] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [Some @Int64 0] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [Some @Int64 0, None @Int64] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [Some @Int64 0, Some @Int64 0] (Nil @(Option Int64))\",\n+            e\"Cons @(Option Int64) [Some @Int64 1, Some @Int64 0] (Nil @(Option Int64))\",\n+          ),\n+          t\"TextMap (Option Int64)\" ->\n+            List(\n+              e\"TEXTMAP_EMPTY @(Option Int64)\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (None @Int64) (TEXTMAP_EMPTY @(Option Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (None @Int64) (TEXTMAP_INSERT @(Option Int64)\"b\" (None @Int64) (TEXTMAP_EMPTY @(Option Int64)))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (None @Int64) (TEXTMAP_INSERT @(Option Int64)\"b\" (Some @Int64 -10) (TEXTMAP_EMPTY @(Option Int64)))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 0) (TEXTMAP_EMPTY @(Option Int64))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 0) (TEXTMAP_INSERT @(Option Int64) \"b\" (None @Int64) (TEXTMAP_EMPTY @(Option Int64)))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 0) (TEXTMAP_INSERT @(Option Int64) \"b\" (Some @Int64 -10) (TEXTMAP_EMPTY @(Option Int64)))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 0) (TEXTMAP_INSERT @(Option Int64) \"b\" (Some @Int64 -10) (TEXTMAP_INSERT @(Option Int64) \"c\" (None @Int64) (TEXTMAP_EMPTY @(Option Int64))))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 0) (TEXTMAP_INSERT @(Option Int64) \"b\" (Some @Int64 -1) (TEXTMAP_EMPTY @(Option Int64)))\"\"\",\n+              e\"\"\"TEXTMAP_INSERT @(Option Int64) \"a\" (Some @Int64 1) (TEXTMAP_EMPTY @(Option Int64))\"\"\",\n+            ),\n+          t\"GenMap Text Int64\" ->\n+            List(\n+              e\"GENMAP_EMPTY @(Option Text) @(Option Int64)\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (None @Int64) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (None @Int64) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (None @Int64) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (None @Int64) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 0) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (None @Int64) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 0) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 0) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"1\") (Some @Int64 2) (GENMAP_EMPTY @(Option Text) @(Option Int64))))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 1) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 1) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (None @Int64) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 1) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64)))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (None @Text) (Some @Int64 1) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"1\") (Some @Int64 2) (GENMAP_EMPTY @(Option Text) @(Option Int64))))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (None @Int64) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"0\") (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"1\") (Some @Int64 0) (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+              e\"\"\"GENMAP_INSERT @(Option Text) @(Option Int64) (Some @Text \"1\") (Some @Int64 1)  (GENMAP_EMPTY @(Option Text) @(Option Int64))\"\"\",\n+            ),\n+          // any\n+          t\"Any\" -> List(\n+            e\"to_any @Int64 -1\",\n+            e\"to_any @Int64 0\",\n+            e\"to_any @Int64 1\",\n+            e\"to_any @Any (to_any @Int64 1)\",\n+            e\"to_any @Any (to_any @Int64 2)\",\n+            e\"to_any @(Option Int64) (None @Int64)\",\n+            e\"to_any @(Option Int64) (Some @Int64 0)\",\n+            e\"to_any @(Option Int64) (Some @Int64 1)\",\n+          ),\n+        )\n+\n+      forEvery(comparableValues) {\n+        case (typ, expr) =>\n+          for {\n+            xi <- expr.zipWithIndex\n+            (x, i) = xi\n+            yj <- expr.zipWithIndex\n+            (y, j) = yj\n+          } {\n+            val diff = i compare j\n+            forEvery(builtins) {\n+              case (bi, result) =>\n+                eval(bi, typ, x, y) shouldBe Right(SValue.SBool(result(diff)))\n+            }\n+          }\n+      }\n+    }\n+\n+    // FIXME: comparison is broken for struct.\n+\n+    \"should not distinguish struct built in different order\" ignore {\n+\n+      val typ = t\"\"\"<first = Int64, second = Int64, third = Int64>\"\"\"\n+\n+      val values = Table(\n+        \"expr\",\n+        e\"\"\"<first = 1, second = 2, third = 3>\"\"\",\n+        e\"\"\"<third = 3, second = 2, first = 1>\"\"\",\n+        e\"\"\"<first = 1, third = 3, second = 2>\"\"\",\n+      )\n+\n+      forEvery(builtins) {\n+        case (bi, _) =>\n+          forEvery(values) { x =>\n+            eval(bi, typ, x, x) shouldBe 'right\n+            forEvery(values) { y =>\n+              eval(bi, typ, x, y) shouldBe 'left"
  }
]