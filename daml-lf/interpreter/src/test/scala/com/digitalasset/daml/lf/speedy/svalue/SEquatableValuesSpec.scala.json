[
  {
    "id" : "68e3da16-e33c-4519-8fe8-ab5dbbedc623",
    "prId" : 3715,
    "comments" : [
      {
        "id" : "677643a2-1e29-4124-b352-a7d828696402",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Is this really necessary?",
        "createdAt" : "2019-12-05T15:39:31Z",
        "updatedAt" : "2019-12-06T15:11:20Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "57679bb2-15d9-463d-b5f1-8dad0bfd2bd6",
        "parentId" : "677643a2-1e29-4124-b352-a7d828696402",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "in fact  not. I dropped it.",
        "createdAt" : "2019-12-06T10:00:42Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0703e5eb35d9a96c6ea7a07d0899920f5b3df5d7",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,337 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, NodeId, RelativeContractId}\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import java.util\n+\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))"
  },
  {
    "id" : "9314fa2a-a7e7-4293-bff8-53509f4610ac",
    "prId" : 3715,
    "comments" : [
      {
        "id" : "d3c8699d-e580-416f-b708-27c473c9be52",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    new util.ArrayList(as.asJava)\r\n```",
        "createdAt" : "2019-12-05T17:07:45Z",
        "updatedAt" : "2019-12-06T15:11:20Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be516291-2667-47f6-97ef-22e217c33ab8",
        "parentId" : "d3c8699d-e580-416f-b708-27c473c9be52",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-12-06T10:00:11Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0703e5eb35d9a96c6ea7a07d0899920f5b3df5d7",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,337 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, NodeId, RelativeContractId}\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import java.util\n+\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+class SEquatableValuesSpec extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  private val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+  implicit def toTypeConName(s: String): Ref.TypeConName =\n+    Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+  implicit def toName(s: String): Ref.Name =\n+    Ref.Name.assertFromString(s)\n+\n+  private val EnumTypeCon: Ref.TypeConName = \"Color\"\n+\n+  private val EnumCon1: Ref.Name = \"Red\"\n+  private val EnumCon2: Ref.Name = \"Green\"\n+\n+  private val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+  private val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+  private val record2Fields = Ref.Name.Array(\"fst\", \"snd\")\n+\n+  private val VariantTypeCon: Ref.TypeConName = \"Either\"\n+  private val VariantCon1: Ref.Name = \"Left\"\n+  private val VariantCon2: Ref.Name = \"Right\"\n+\n+  private val units =\n+    List(SValue.SValue.Unit)\n+  private val bools =\n+    List(SValue.SValue.True, SValue.SValue.False)\n+  private val ints =\n+    List(SInt64(-1L), SInt64(0L), SInt64(1L))\n+  private val decimals =\n+    List(\"-10000.0000000000\", \"0.0000000000\", \"10000.0000000000\")\n+      .map(x => SNumeric(Numeric.assertFromString(x)))\n+  private val numerics =\n+    List(\"-10000.\", \"0.\", \"10000.\").map(SNumeric compose Numeric.assertFromString)\n+  private val texts =\n+    List(\"\"\"\"some text\"\"\"\", \"\"\"\"some other text\"\"\"\").map(SText)\n+  private val dates =\n+    List(\"1969-07-21\", \"1970-01-01\").map(SDate compose Time.Date.assertFromString)\n+  private val timestamps =\n+    List(\"1969-07-21T02:56:15.000000Z\", \"1970-01-01T00:00:00.000000Z\")\n+      .map(STimestamp compose Time.Timestamp.assertFromString)\n+  private val parties =\n+    List(\"alice\", \"bob\").map(SParty compose Ref.Party.assertFromString)\n+  private val absoluteContractId =\n+    List(\"a\", \"b\")\n+      .map(x => SContractId(AbsoluteContractId(Ref.ContractIdString.assertFromString(x))))\n+  private val relativeContractId =\n+    List(0, 1).map(x => SContractId(RelativeContractId(NodeId.unsafeFromIndex(x))))\n+  private val contractIds = absoluteContractId ++ relativeContractId\n+\n+  private val enums = List(EnumCon1, EnumCon2).map(SEnum(EnumTypeCon, _))\n+\n+  private val struct0 = List(SStruct(Ref.Name.Array.empty, ArrayList()))\n+\n+  private val records0 = List(SRecord(Record0TypeCon, Ref.Name.Array.empty, ArrayList()))\n+\n+  private val typeReps = List(\n+    AstUtil.TUnit,\n+    AstUtil.TList(AstUtil.TContractId(Ast.TTyCon(Record0TypeCon))),\n+    AstUtil.TUpdate(Ast.TTyCon(EnumTypeCon)),\n+  ).map(STypeRep)\n+\n+  private def mkRecord2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n+\n+  private def mkVariant(as: List[SValue], bs: List[SValue]) =\n+    as.map(SVariant(VariantTypeCon, VariantCon1, _)) ++\n+      bs.map(SVariant(VariantTypeCon, VariantCon2, _))\n+\n+  private def mkStruct2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SStruct(record2Fields, ArrayList(x, y))\n+\n+  private def lists(atLeast3Values: List[SValue]) = {\n+    val a :: b :: c :: _ = atLeast3Values\n+    List(\n+      List(),\n+      List(a),\n+      List(b),\n+      List(a, a),\n+      List(b, b),\n+      List(a, b),\n+      List(a, a, a),\n+      List(b, b, b),\n+      List(a, a, b),\n+      List(b, b, a),\n+      List(a, b, a),\n+      List(b, a, b),\n+      List(a, b, b),\n+      List(b, a, a),\n+      List(a, b, c),\n+      List(c, a, b),\n+    )\n+  }\n+\n+  private def optLists(atLeast3Values: List[SValue]) = {\n+    val a :: b :: c :: _ = atLeast3Values\n+    val x = SOptional(None)\n+    List(\n+      List(),\n+      List(a),\n+      List(b),\n+      List(x),\n+      List(a, a),\n+      List(b, b),\n+      List(x, x),\n+      List(a, b),\n+      List(a, x),\n+      List(x, a),\n+      List(a, a, a),\n+      List(b, b, b),\n+      List(x, x, x),\n+      List(a, a, b),\n+      List(a, a, x),\n+      List(b, b, a),\n+      List(x, x, a),\n+      List(a, b, a),\n+      List(a, x, a),\n+      List(b, a, b),\n+      List(x, a, x),\n+      List(a, b, b),\n+      List(a, x, x),\n+      List(b, a, a),\n+      List(x, a, a),\n+      List(x, a, b),\n+      List(a, b, c),\n+      List(a, x, c),\n+      List(a, b, x),\n+      List(c, a, b),\n+      List(c, a, x),\n+    )\n+  }\n+\n+  private def mkOptionals(values: List[SValue]): List[SValue] =\n+    SOptional(None) +: values.map(x => SOptional(Some(x)))\n+\n+  private def mkLists(lists: List[List[SValue]]): List[SValue] =\n+    lists.map(xs => SList(FrontStack(xs)))\n+\n+  private def mkTextMaps(lists: List[List[SValue]]): List[SValue] = {\n+    val keys = List(\"a\", \"b\", \"c\")\n+    lists.map(xs => STextMap(HashMap(keys zip xs: _*)))\n+  }\n+\n+  private def mkGenMaps(keys: List[SValue], lists: List[List[SValue]]): List[SValue] = {\n+    val skeys = keys.map(SGenMap.Key(_))\n+    lists.map(xs => SGenMap(InsertOrdMap(skeys zip xs: _*)))\n+  }\n+\n+  private def anys = {\n+    val wrappedInts = ints.map(SAny(AstUtil.TInt64, _))\n+    val wrappedIntOptional = ints.map(SAny(AstUtil.TOptional(AstUtil.TInt64), _))\n+    val wrappedAnyInts = wrappedInts.map(SAny(AstUtil.TAny, _))\n+    // add a bit more cases  here\n+    wrappedInts ++ wrappedIntOptional ++ wrappedAnyInts\n+  }\n+\n+  private val equatableValues: TableFor1[TableFor1[SValue]] = Table(\n+    \"equatable values\",\n+    // Atomic values\n+    Table(\"Unit\", units: _*),\n+    Table(\"Bool\", bools: _*),\n+    Table(\"Int64\", ints: _*),\n+    Table(\"Decimal\", decimals: _*),\n+    Table(\"Numeric0\", numerics: _*),\n+    Table(\"Text\", texts: _*),\n+    Table(\"Date\", dates: _*),\n+    Table(\"Timestamp\", timestamps: _*),\n+    Table(\"party\", parties: _*),\n+    Table(\"contractId\", contractIds: _*),\n+    Table(\"enum\", enums: _*),\n+    Table(\"record0\", records0: _*),\n+    Table(\"struct0\", struct0: _*),\n+    Table(\"typeRep\", typeReps: _*),\n+    // 1 level nested values\n+    Table(\"record2_1\", mkRecord2(texts, texts): _*),\n+    Table(\"variant_1\", mkVariant(texts, texts): _*),\n+    Table(\"struct2_1\", mkStruct2(texts, texts): _*),\n+    Table(\"optional_1\", mkOptionals(texts): _*),\n+    Table(\"list_1\", mkLists(lists(ints)): _*),\n+    Table(\"textMap_1\", mkTextMaps(lists(ints)): _*),\n+    Table(\"genMap_1\", mkGenMaps(ints, lists(ints)): _*),\n+    // 2 level nested values\n+    Table(\"record2_2\", mkRecord2(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"variant_2\", mkVariant(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"struct2_2\", mkStruct2(mkOptionals(texts), mkOptionals(texts)): _*),\n+    Table(\"optional_2\", mkOptionals(mkOptionals(texts)): _*),\n+    Table(\"list_2\", mkLists(optLists(ints)): _*),\n+    Table(\"textMap_2\", mkTextMaps(optLists(ints)): _*),\n+    Table(\"genMap_2\", mkGenMaps(mkOptionals(ints), optLists(ints)): _*),\n+    // any\n+    Table(\"any\", anys: _*)\n+  )\n+\n+  private val lfFunction = SPAP(PBuiltin(SBuiltin.SBAddInt64), ArrayList(SInt64(1)), 2)\n+\n+  private val funs = List(\n+    lfFunction,\n+    SPAP(PClosure(SExpr.SEVar(2), Array()), ArrayList(SValue.SValue.Unit), 2),\n+  )\n+\n+  private def nonEquatableLists(atLeast2InEquatableValues: List[SValue]) = {\n+    val a :: b :: _ = atLeast2InEquatableValues\n+    List(\n+      List(a),\n+      List(b),\n+      List(a, a),\n+      List(b, b),\n+      List(a, b),\n+    )\n+  }\n+\n+  private def nonEquatableAnys = {\n+    val Type0 = AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64)\n+    val wrappedFuns = funs.map(SAny(Type0, _))\n+    val wrappedFunOptional = funs.map(SAny(AstUtil.TOptional(Type0), _))\n+    val wrappedAnyFuns = wrappedFuns.map(SAny(AstUtil.TAny, _))\n+    // add a bit more cases  here\n+    wrappedFuns ++ wrappedFunOptional ++ wrappedAnyFuns\n+  }\n+\n+  private val nonEquatableValues =\n+    Table(\n+      \"nonEquatable values\",\n+      Table(\"funs\", funs: _*),\n+      Table(\"token\", SValue.SToken),\n+      Table(\"nat\", SValue.STNat(Numeric.Scale.MinValue), SValue.STNat(Numeric.Scale.MaxValue)),\n+      Table(\"nonEquatable record\", mkRecord2(funs, units) ++ mkRecord2(units, funs): _*),\n+      Table(\"nonEquatable struct\", mkStruct2(funs, units) ++ mkStruct2(units, funs): _*),\n+      Table(\"nonEquatable optional\", funs.map(x => SOptional(Some(x))): _*),\n+      Table(\"nonEquatable list\", mkLists(nonEquatableLists(funs)): _*),\n+      Table(\"nonEquatable textMap\", mkTextMaps(nonEquatableLists(funs)): _*),\n+      Table(\"nonEquatable genMap\", mkGenMaps(ints, nonEquatableLists(funs)): _*),\n+      Table(\"nonEquatable variant\", mkVariant(funs, funs): _*),\n+      Table(\"nonEquatable any\", nonEquatableAnys: _*)\n+    )\n+\n+  private val nonEquatableWithEquatableValues: TableFor2[SValue, SValue] =\n+    Table(\n+      \"nonEquatable values\" -> \"equatable values\",\n+      SOptional(None) ->\n+        SOptional(Some(lfFunction)),\n+      SList(FrontStack.empty) ->\n+        SList(FrontStack(lfFunction)),\n+      STextMap(HashMap.empty) ->\n+        STextMap(HashMap(\"a\" -> lfFunction)),\n+      SGenMap(InsertOrdMap.empty) -> SGenMap(InsertOrdMap(SGenMap.Key(SInt64(0)) -> lfFunction)),\n+      SVariant(VariantTypeCon, VariantCon1, SInt64(0)) ->\n+        SVariant(VariantTypeCon, VariantCon2, lfFunction),\n+      SAny(AstUtil.TInt64, SInt64(1)) ->\n+        SAny(AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64), lfFunction)\n+    )\n+\n+  \"Equality.areEqual\" should {\n+\n+    // In the following tests, we check only well-type equalities\n+\n+    \"be reflexive on equatable values\" in {\n+      forEvery(equatableValues)(atoms => forEvery(atoms)(x => assert(Equality.areEqual(x, x))))\n+    }\n+\n+    \"return false when applied on two on different equatable values\" in {\n+      forAll(equatableValues)(atoms =>\n+        for {\n+          (x, i) <- atoms.zipWithIndex\n+          (y, j) <- atoms.zipWithIndex\n+          if i != j\n+        } assert(!Equality.areEqual(x, y)))\n+    }\n+\n+    \"be irreflexive on non-equatable values\" in {\n+      forEvery(nonEquatableValues)(atoms => forEvery(atoms)(x => assert(!Equality.areEqual(x, x))))\n+    }\n+\n+    \"return false when applied on two different non-equatable values\" in {\n+      forAll(nonEquatableValues)(atoms =>\n+        for {\n+          (x, i) <- atoms.zipWithIndex\n+          (y, j) <- atoms.zipWithIndex\n+          if i != j\n+        } assert(!Equality.areEqual(x, y)))\n+    }\n+\n+    \"return false when applied on an equatable and a nonEquatable values\" in {\n+      forEvery(nonEquatableWithEquatableValues) {\n+        case (nonEq, eq) =>\n+          assert(!Equality.areEqual(nonEq, eq))\n+          assert(!Equality.areEqual(eq, nonEq))\n+      }\n+    }\n+  }\n+\n+  \"Hasher.hashCode\" should {\n+\n+    \"not fail on equatable values\" in {\n+      forEvery(equatableValues)(atoms => forEvery(atoms)(Hasher.hash))\n+    }\n+\n+    \"fail on non-equatable values\" in {\n+      forEvery(nonEquatableValues)(atoms =>\n+        forEvery(atoms)(x => a[Hasher.NonHashableSValue] should be thrownBy Hasher.hash(x)))\n+    }\n+\n+  }\n+\n+  private def ArrayList[X](as: X*): util.ArrayList[X] = {\n+    val a = new util.ArrayList[X](as.length)\n+    as.foreach(a.add)\n+    a"
  },
  {
    "id" : "cb8978a8-6a46-4254-a66c-14325a8716e4",
    "prId" : 3715,
    "comments" : [
      {
        "id" : "bd06ba58-0cb9-4aac-bf25-f3cd8f02d8f8",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```scala\r\n    val s = List(x, a, b, c)\r\n    List.empty :: (List(s).sequence ++ List(s, s).sequence ++ List(s, s, s).sequence)\r\n```",
        "createdAt" : "2019-12-05T19:52:52Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "56102fd6-9220-49c9-84c3-bc9bad97100d",
        "parentId" : "bd06ba58-0cb9-4aac-bf25-f3cd8f02d8f8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-12-06T10:00:19Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0703e5eb35d9a96c6ea7a07d0899920f5b3df5d7",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,337 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, NodeId, RelativeContractId}\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import java.util\n+\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+class SEquatableValuesSpec extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  private val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+  implicit def toTypeConName(s: String): Ref.TypeConName =\n+    Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+  implicit def toName(s: String): Ref.Name =\n+    Ref.Name.assertFromString(s)\n+\n+  private val EnumTypeCon: Ref.TypeConName = \"Color\"\n+\n+  private val EnumCon1: Ref.Name = \"Red\"\n+  private val EnumCon2: Ref.Name = \"Green\"\n+\n+  private val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+  private val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+  private val record2Fields = Ref.Name.Array(\"fst\", \"snd\")\n+\n+  private val VariantTypeCon: Ref.TypeConName = \"Either\"\n+  private val VariantCon1: Ref.Name = \"Left\"\n+  private val VariantCon2: Ref.Name = \"Right\"\n+\n+  private val units =\n+    List(SValue.SValue.Unit)\n+  private val bools =\n+    List(SValue.SValue.True, SValue.SValue.False)\n+  private val ints =\n+    List(SInt64(-1L), SInt64(0L), SInt64(1L))\n+  private val decimals =\n+    List(\"-10000.0000000000\", \"0.0000000000\", \"10000.0000000000\")\n+      .map(x => SNumeric(Numeric.assertFromString(x)))\n+  private val numerics =\n+    List(\"-10000.\", \"0.\", \"10000.\").map(SNumeric compose Numeric.assertFromString)\n+  private val texts =\n+    List(\"\"\"\"some text\"\"\"\", \"\"\"\"some other text\"\"\"\").map(SText)\n+  private val dates =\n+    List(\"1969-07-21\", \"1970-01-01\").map(SDate compose Time.Date.assertFromString)\n+  private val timestamps =\n+    List(\"1969-07-21T02:56:15.000000Z\", \"1970-01-01T00:00:00.000000Z\")\n+      .map(STimestamp compose Time.Timestamp.assertFromString)\n+  private val parties =\n+    List(\"alice\", \"bob\").map(SParty compose Ref.Party.assertFromString)\n+  private val absoluteContractId =\n+    List(\"a\", \"b\")\n+      .map(x => SContractId(AbsoluteContractId(Ref.ContractIdString.assertFromString(x))))\n+  private val relativeContractId =\n+    List(0, 1).map(x => SContractId(RelativeContractId(NodeId.unsafeFromIndex(x))))\n+  private val contractIds = absoluteContractId ++ relativeContractId\n+\n+  private val enums = List(EnumCon1, EnumCon2).map(SEnum(EnumTypeCon, _))\n+\n+  private val struct0 = List(SStruct(Ref.Name.Array.empty, ArrayList()))\n+\n+  private val records0 = List(SRecord(Record0TypeCon, Ref.Name.Array.empty, ArrayList()))\n+\n+  private val typeReps = List(\n+    AstUtil.TUnit,\n+    AstUtil.TList(AstUtil.TContractId(Ast.TTyCon(Record0TypeCon))),\n+    AstUtil.TUpdate(Ast.TTyCon(EnumTypeCon)),\n+  ).map(STypeRep)\n+\n+  private def mkRecord2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n+\n+  private def mkVariant(as: List[SValue], bs: List[SValue]) =\n+    as.map(SVariant(VariantTypeCon, VariantCon1, _)) ++\n+      bs.map(SVariant(VariantTypeCon, VariantCon2, _))\n+\n+  private def mkStruct2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SStruct(record2Fields, ArrayList(x, y))\n+\n+  private def lists(atLeast3Values: List[SValue]) = {\n+    val a :: b :: c :: _ = atLeast3Values\n+    List(\n+      List(),\n+      List(a),\n+      List(b),\n+      List(a, a),\n+      List(b, b),\n+      List(a, b),\n+      List(a, a, a),\n+      List(b, b, b),\n+      List(a, a, b),\n+      List(b, b, a),\n+      List(a, b, a),\n+      List(b, a, b),\n+      List(a, b, b),\n+      List(b, a, a),\n+      List(a, b, c),\n+      List(c, a, b),\n+    )\n+  }\n+\n+  private def optLists(atLeast3Values: List[SValue]) = {\n+    val a :: b :: c :: _ = atLeast3Values\n+    val x = SOptional(None)\n+    List("
  },
  {
    "id" : "a71526aa-7f1c-4f24-a7c5-e5f8d5249747",
    "prId" : 3715,
    "comments" : [
      {
        "id" : "d13a53d4-a1ce-4886-b85c-432f20d7ae91",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Like `optLists` with `val s = List(a, b, c)`.",
        "createdAt" : "2019-12-05T19:53:20Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "994e1038-f03d-47b0-b2e0-4bc40d429831",
        "parentId" : "d13a53d4-a1ce-4886-b85c-432f20d7ae91",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2019-12-06T10:00:27Z",
        "updatedAt" : "2019-12-06T15:11:21Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0703e5eb35d9a96c6ea7a07d0899920f5b3df5d7",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,337 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import com.digitalasset.daml.lf.data.{FrontStack, InsertOrdMap, Numeric, Ref, Time}\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, NodeId, RelativeContractId}\n+import org.scalatest.prop.{TableDrivenPropertyChecks, TableFor1, TableFor2}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.collection.immutable.HashMap\n+import scala.language.implicitConversions\n+import java.util\n+\n+import com.digitalasset.daml.lf.language.{Ast, Util => AstUtil}\n+import com.digitalasset.daml.lf.speedy.{SBuiltin, SExpr, SValue}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+class SEquatableValuesSpec extends WordSpec with Matchers with TableDrivenPropertyChecks {\n+\n+  private val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+  implicit def toTypeConName(s: String): Ref.TypeConName =\n+    Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+  implicit def toName(s: String): Ref.Name =\n+    Ref.Name.assertFromString(s)\n+\n+  private val EnumTypeCon: Ref.TypeConName = \"Color\"\n+\n+  private val EnumCon1: Ref.Name = \"Red\"\n+  private val EnumCon2: Ref.Name = \"Green\"\n+\n+  private val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+  private val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+  private val record2Fields = Ref.Name.Array(\"fst\", \"snd\")\n+\n+  private val VariantTypeCon: Ref.TypeConName = \"Either\"\n+  private val VariantCon1: Ref.Name = \"Left\"\n+  private val VariantCon2: Ref.Name = \"Right\"\n+\n+  private val units =\n+    List(SValue.SValue.Unit)\n+  private val bools =\n+    List(SValue.SValue.True, SValue.SValue.False)\n+  private val ints =\n+    List(SInt64(-1L), SInt64(0L), SInt64(1L))\n+  private val decimals =\n+    List(\"-10000.0000000000\", \"0.0000000000\", \"10000.0000000000\")\n+      .map(x => SNumeric(Numeric.assertFromString(x)))\n+  private val numerics =\n+    List(\"-10000.\", \"0.\", \"10000.\").map(SNumeric compose Numeric.assertFromString)\n+  private val texts =\n+    List(\"\"\"\"some text\"\"\"\", \"\"\"\"some other text\"\"\"\").map(SText)\n+  private val dates =\n+    List(\"1969-07-21\", \"1970-01-01\").map(SDate compose Time.Date.assertFromString)\n+  private val timestamps =\n+    List(\"1969-07-21T02:56:15.000000Z\", \"1970-01-01T00:00:00.000000Z\")\n+      .map(STimestamp compose Time.Timestamp.assertFromString)\n+  private val parties =\n+    List(\"alice\", \"bob\").map(SParty compose Ref.Party.assertFromString)\n+  private val absoluteContractId =\n+    List(\"a\", \"b\")\n+      .map(x => SContractId(AbsoluteContractId(Ref.ContractIdString.assertFromString(x))))\n+  private val relativeContractId =\n+    List(0, 1).map(x => SContractId(RelativeContractId(NodeId.unsafeFromIndex(x))))\n+  private val contractIds = absoluteContractId ++ relativeContractId\n+\n+  private val enums = List(EnumCon1, EnumCon2).map(SEnum(EnumTypeCon, _))\n+\n+  private val struct0 = List(SStruct(Ref.Name.Array.empty, ArrayList()))\n+\n+  private val records0 = List(SRecord(Record0TypeCon, Ref.Name.Array.empty, ArrayList()))\n+\n+  private val typeReps = List(\n+    AstUtil.TUnit,\n+    AstUtil.TList(AstUtil.TContractId(Ast.TTyCon(Record0TypeCon))),\n+    AstUtil.TUpdate(Ast.TTyCon(EnumTypeCon)),\n+  ).map(STypeRep)\n+\n+  private def mkRecord2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n+\n+  private def mkVariant(as: List[SValue], bs: List[SValue]) =\n+    as.map(SVariant(VariantTypeCon, VariantCon1, _)) ++\n+      bs.map(SVariant(VariantTypeCon, VariantCon2, _))\n+\n+  private def mkStruct2(fst: List[SValue], snd: List[SValue]) =\n+    for {\n+      x <- fst\n+      y <- snd\n+    } yield SStruct(record2Fields, ArrayList(x, y))\n+\n+  private def lists(atLeast3Values: List[SValue]) = {\n+    val a :: b :: c :: _ = atLeast3Values\n+    List("
  }
]