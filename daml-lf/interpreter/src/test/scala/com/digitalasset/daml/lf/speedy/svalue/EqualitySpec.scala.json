[
  {
    "id" : "3d70f899-32f1-4a85-860c-663d99beb869",
    "prId" : 7326,
    "comments" : [
      {
        "id" : "0d7982eb-abe9-4992-91b9-abeb2885cdc1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why can we delete this whole test suite?",
        "createdAt" : "2020-09-08T11:08:20Z",
        "updatedAt" : "2020-09-08T12:58:37Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "74936576-1ce4-4bcb-986b-5b6f339d8d76",
        "parentId" : "0d7982eb-abe9-4992-91b9-abeb2885cdc1",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "This is tested extensively in [ComparisonSBuiltinTest](https://github.com/digital-asset/daml/blob/master/daml-lf/interpreter/src/test/scala/com/digitalasset/daml/lf/speedy/ComparisonSBuiltinTest.scala)",
        "createdAt" : "2020-09-08T12:23:38Z",
        "updatedAt" : "2020-09-08T12:58:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "620b799dfe99df2b5819c91217f1681670647668",
    "line" : 1,
    "diffHunk" : "@@ -1,470 +0,0 @@\n-// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved."
  },
  {
    "id" : "b93b911f-c9bf-41bf-921e-276b156525ee",
    "prId" : 7319,
    "comments" : [
      {
        "id" : "e32e7e9d-0c55-4ce5-9faf-b60fc6e019d3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why not like in all other places?\r\n```suggestion\r\n    Struct.assertFromSeq(List(n\"fst\" -> (()), n\"snd\" -> (())))\r\n```",
        "createdAt" : "2020-09-04T11:15:45Z",
        "updatedAt" : "2020-09-04T16:34:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abf995d1e965f73aac6422c0d37ee6362850f920",
    "line" : null,
    "diffHunk" : "@@ -44,7 +44,8 @@ class EqualitySpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n   private val VariantCon1: Ref.Name = \"Left\"\n   private val VariantCon2: Ref.Name = \"Right\"\n \n-  private val struct2Fields = ImmArray[Ref.Name](\"fst\", \"snd\")\n+  private val struct2Fields =\n+    Struct.assertFromSeq(List[Ref.Name](\"fst\", \"snd\") zip Stream.continually(()))"
  },
  {
    "id" : "23371c3b-9790-4932-9469-ae26b52e89f5",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "fc541dbb-1c0f-4cca-9e02-91e854a1fff1",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n    \"shortcut list\" in {\r\n```",
        "createdAt" : "2020-08-12T07:19:39Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -266,6 +266,18 @@ class EqualitySpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n           assert(!Equality.areEqual(eq, nonEq))\n       }\n     }\n+\n+    \"shortcup list\" in {"
  },
  {
    "id" : "9b31cecd-e570-4e59-9334-78dd94758d89",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "14b77e27-6948-4915-a049-f41fdaac24fd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We don't have test cases where the comparison of the keys fails here, do we? If not, we should add some.",
        "createdAt" : "2020-08-20T09:28:39Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "47a2569a-a13c-48e0-9239-1c9b5f2666d7",
        "parentId" : "14b77e27-6948-4915-a049-f41fdaac24fd",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I added some test cases.",
        "createdAt" : "2020-08-20T12:35:59Z",
        "updatedAt" : "2020-08-20T12:35:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : 237,
    "diffHunk" : "@@ -217,55 +221,217 @@ class EqualitySpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n     Table(\n       \"nonEquatable values\" -> \"equatable values\",\n       SOptional(None) ->\n-        SOptional(Some(lfFunction)),\n+        SOptional(Some(fun)),\n       SList(FrontStack.empty) ->\n-        SList(FrontStack(lfFunction)),\n+        SList(FrontStack(fun)),\n       STextMap(HashMap.empty) ->\n-        STextMap(HashMap(\"a\" -> lfFunction)),\n-      SGenMap.Empty -> SGenMap(SInt64(0) -> lfFunction),\n+        STextMap(HashMap(\"a\" -> fun)),\n+      SGenMap.Empty -> SGenMap(SInt64(0) -> fun),\n       SVariant(VariantTypeCon, VariantCon1, 0, SInt64(0)) ->\n-        SVariant(VariantTypeCon, VariantCon2, 1, lfFunction),\n+        SVariant(VariantTypeCon, VariantCon2, 1, fun),\n       SAny(AstUtil.TInt64, SInt64(1)) ->\n-        SAny(AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64), lfFunction),\n+        SAny(AstUtil.TFun(AstUtil.TInt64, AstUtil.TInt64), fun),\n     )\n \n   \"Equality.areEqual\" should {\n \n+    import Equality.areEqual\n+\n     // In the following tests, we check only well-type equalities\n \n     \"be reflexive on equatable values\" in {\n-      forEvery(equatableValues)(atoms => forEvery(atoms)(x => assert(Equality.areEqual(x, x))))\n+      forEvery(equatableValues)(atoms => forEvery(atoms)(x => assert(areEqual(x, x))))\n     }\n \n-    \"return false when applied on two on different equatable values\" in {\n+    \"return false when applied on two different equatable values\" in {\n       forAll(equatableValues)(atoms =>\n         for {\n           (x, i) <- atoms.zipWithIndex\n           (y, j) <- atoms.zipWithIndex\n           if i != j\n-        } assert(!Equality.areEqual(x, y)))\n-    }\n-\n-    \"be irreflexive on non-equatable values\" in {\n-      forEvery(nonEquatableValues)(atoms => forEvery(atoms)(x => assert(!Equality.areEqual(x, x))))\n+        } assert(!areEqual(x, y)))\n     }\n \n-    \"return false when applied on two different non-equatable values\" in {\n-      forAll(nonEquatableValues)(atoms =>\n-        for {\n-          (x, i) <- atoms.zipWithIndex\n-          (y, j) <- atoms.zipWithIndex\n-          if i != j\n-        } assert(!Equality.areEqual(x, y)))\n+    \"fail on non-equatable values\" in {\n+      forEvery(nonEquatableValues)(atoms =>\n+        forEvery(atoms)(x => an[SErrorCrash] should be thrownBy areEqual(x, x)))\n     }\n \n     \"return false when applied on an equatable and a nonEquatable values\" in {\n       forEvery(nonEquatableWithEquatableValues) {\n         case (nonEq, eq) =>\n-          assert(!Equality.areEqual(nonEq, eq))\n-          assert(!Equality.areEqual(eq, nonEq))\n+          assert(!areEqual(nonEq, eq))\n+          assert(!areEqual(eq, nonEq))\n+      }\n+    }\n+\n+    val x1 = SVariant(VariantTypeCon, VariantCon1, 0, SInt64(1))\n+    val x2 = SVariant(VariantTypeCon, VariantCon1, 0, SInt64(2))\n+    val u = SVariant(VariantTypeCon, VariantCon2, 1, fun)\n+\n+    \"shortcut failure in records \" in {\n+      def record(x: SValue, y: SValue) =\n+        SRecord(Record2TypeCon, record2Fields, ArrayList(x, y))\n+\n+      val negativeTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        record(u, x1) -> record(u, x1),\n+        record(u, x1) -> record(u, x2),\n+        record(x1, u) -> record(x1, u)\n+      )\n+      val positiveTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        record(x1, u) -> record(x2, u)\n+      )\n+\n+      forEvery(negativeTestCases)((x, y) => an[SErrorCrash] should be thrownBy areEqual(x, y))\n+      forEvery(positiveTestCases)((x, y) => areEqual(x, y))\n+    }\n+\n+    \"shortcut failure in variant\" in {\n+      val negativeTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        u -> u,\n+      )\n+      val positiveTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        u -> x1\n+      )\n+      forEvery(negativeTestCases) { (x, y) =>\n+        an[SErrorCrash] should be thrownBy areEqual(x, y)\n+        an[SErrorCrash] should be thrownBy areEqual(y, x)\n+      }\n+      forEvery(positiveTestCases) { (x, y) =>\n+        areEqual(x, y)\n+        areEqual(y, x)\n+      }\n+    }\n+\n+    \"shortcut failure in list\" in {\n+      def list(xs: SValue*) = SList(FrontStack(xs))\n+\n+      val negativeTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        list(u) -> list(u),\n+        list(u, x1) -> list(u),\n+        list(x1, u) -> list(x1, u),\n+        list(x1, u, x1) -> list(x1, u),\n+      )\n+      val positiveTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        list(x1, u) -> list(x2, u),\n+        list(u) -> list(),\n+        list() -> list(u)\n+      )\n+\n+      forEvery(negativeTestCases) { (x, y) =>\n+        an[SErrorCrash] should be thrownBy areEqual(x, y)\n+        an[SErrorCrash] should be thrownBy areEqual(y, x)\n+      }\n+      forEvery(positiveTestCases) { (x, y) =>\n+        areEqual(x, y)\n+        areEqual(y, x)\n+      }\n+    }\n+\n+    \"shortcut failure in optional\" in {\n+      val negativeTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        SOptional(Some(u)) -> SOptional(Some(u)),\n+      )\n+      val positiveTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        SOptional(None) -> SOptional(Some(u))\n+      )\n+      forEvery(negativeTestCases) { (x, y) =>\n+        an[SErrorCrash] should be thrownBy areEqual(x, y)\n+        an[SErrorCrash] should be thrownBy areEqual(y, x)\n+      }\n+      forEvery(positiveTestCases) { (x, y) =>\n+        areEqual(x, y)\n+        areEqual(y, x)\n+      }\n+    }\n+\n+    \"shortcut failure in text map\" in {\n+      def map(xs: (String, SValue)*) = STextMap(HashMap(xs: _*))\n+\n+      val k1 = \"a\"\n+      val k2 = \"b\"\n+      assert(\"a\" < \"b\")\n+\n+      val negativeTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        map(k1 -> u) -> map(k1 -> u),\n+        map(k1 -> u, k2 -> x1) -> map(k1 -> u),\n+        map(k1 -> u, k2 -> x1) -> map(k1 -> u, k2 -> x2),\n+        map(k1 -> x1, k2 -> u) -> map(k1 -> x1, k2 -> u),\n+      )\n+      val positiveTestCases = Table(\n+        \"first arg\" -> \"second arg\",\n+        map(k1 -> x1, k2 -> u) -> map(k1 -> x2, k2 -> u),\n+        map(k1 -> x1, k2 -> u) -> map(k2 -> u),\n+        map(k1 -> u) -> map(),\n+      )\n+      forEvery(negativeTestCases) { (x, y) =>\n+        an[SErrorCrash] should be thrownBy areEqual(x, y)\n+        an[SErrorCrash] should be thrownBy areEqual(y, x)\n+      }\n+      forEvery(positiveTestCases) { (x, y) =>\n+        areEqual(x, y)\n+        areEqual(y, x)\n       }\n     }\n+\n+    \"shortcut failure in gen map\" in {"
  },
  {
    "id" : "510f440c-d199-4d8b-9bac-36598958b4f3",
    "prId" : 5048,
    "comments" : [
      {
        "id" : "59f3a054-74f4-434f-b2bd-405fc835e862",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That’s still 1-based.",
        "createdAt" : "2020-03-18T09:44:11Z",
        "updatedAt" : "2020-03-18T12:46:43Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a58b8b64400741795af304d763a8e244b07dcb09",
    "line" : null,
    "diffHunk" : "@@ -69,7 +69,10 @@ class EqualitySpec extends WordSpec with Matchers with TableDrivenPropertyChecks\n     List(0, 1).map(x => SContractId(RelativeContractId(NodeId(x))))\n   private val contractIds = absoluteContractId ++ relativeContractId\n \n-  private val enums = List(EnumCon1, EnumCon2).map(SEnum(EnumTypeCon, _))\n+  private val enums = List(\n+    SEnum(EnumTypeCon, EnumCon1, 1),"
  }
]