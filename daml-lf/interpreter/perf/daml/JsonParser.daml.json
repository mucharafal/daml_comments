[
  {
    "id" : "b837154e-4969-4c67-9f2d-5cf607ea414a",
    "prId" : 6239,
    "comments" : [
      {
        "id" : "9539e8ed-193d-4d89-aa40-d96a9a4ae8e1",
        "parentId" : null,
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "This is very high order. It might be a good reflection of certain DAML code.",
        "createdAt" : "2020-06-05T14:19:03Z",
        "updatedAt" : "2020-06-05T14:22:11Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cbcaccf37d5bdab867fd9c0b0b49a574c8816849",
    "line" : 214,
    "diffHunk" : "@@ -0,0 +1,293 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# OPTIONS_GHC -Wall -Wno-name-shadowing #-}\n+\n+-- This is not an industial strength JSON parser! (Although it is fairly complete)\n+-- The DAML code is written for sole intent of having a semi-realistic computationally heavy exmaple.\n+-- The JSON parser is based on the Crockford grammar: https://www.json.org/json-en.html\n+-- The parser is written using parser-combinators, following:\n+--   \"Parser combinators need four values to report errors\", Andrew Partridge & David Wright\n+\n+module JsonParser (pipeline) where\n+\n+import Prelude hiding (null,length)\n+import DA.List (length)\n+import DA.Optional (fromSome)\n+import DA.Text (implode,explode,parseInt)\n+import qualified DA.Text as Text\n+\n+\n+-- Pipeline: generate JSON; convert to string; parse; eval\n+pipeline : Int -> Int\n+pipeline n = do\n+  let ast0 = nfibJ n -- generate\n+  let res0 = eval ast0\n+  let str = show ast0 -- convert to string\n+  let len = Text.length str\n+  let ast1 = parse str\n+  let res1 = eval ast1\n+  if (res1 /= res0) then error \"res1 <> res0\" else\n+    len\n+\n+-- Construct an arithmetic expression for an nfib calculation in JSON\n+nfibJ : Int -> Json\n+nfibJ 0 = lit 1\n+nfibJ 1 = lit 1\n+nfibJ n = add (lit 1) (add (nfibJ (n-1)) (nfibJ (n-2)))\n+\n+\n+-- Constructors for JSON rep of simple arithmetic expressions\n+lit : Int -> Json\n+lit n = Jobject [(\"lit\", Jnumber n),(\"extra\",Jstring\"info\")]\n+\n+add : Json -> Json -> Json\n+add x y = Jobject [(\"op\", Jarray [x,y]), (\"isAdd\",Jtrue)]\n+\n+\n+-- Evaluate JSON represented arithmetic expressions\n+eval : Json -> Int\n+eval = \\case\n+  Jobject [(\"lit\", Jnumber n),(\"extra\",Jstring _)] -> n\n+  Jobject [(\"op\", Jarray [x,y]), (\"isAdd\",Jtrue)] -> eval x + eval y\n+  Jobject [(\"op\", Jarray [x,y]), (\"isAdd\",Jfalse)] -> eval x - eval y\n+  x -> error $ \"eval unexpected ast: \" <> show x\n+\n+\n+-- AST for JSON\n+type Member = (Text,Json)\n+data Json\n+  = Jobject [Member]\n+  | Jarray [Json]\n+  | Jstring Text\n+  | Jnumber Int\n+  | Jtrue\n+  | Jfalse\n+  | Jnull\n+\n+\n+-- Convert JSON to a string: Collect all the text chunks and implode them at the end\n+instance Show Json where\n+  show json = implode (reverse (chunks [] json))\n+\n+chunks : [Text] -> Json -> [Text]\n+chunks acc = \\case\n+  Jobject [] -> \"{}\" :: acc\n+  Jobject (x::xs) ->\n+    \" }\" :: foldl (\\acc x -> chunksMember (\", \" :: acc) x) (chunksMember (\"{ \" :: acc) x) xs\n+  Jarray [] -> \"[]\" :: acc\n+  Jarray (x::xs) ->\n+    \" ]\" :: foldl (\\acc x -> chunks (\", \" :: acc) x) (chunks (\"[ \" :: acc) x) xs\n+  Jstring s -> show s :: acc\n+  Jnumber n -> show n :: acc\n+  Jtrue -> \"true\" :: acc\n+  Jfalse -> \"false\" :: acc\n+  Jnull -> \"null\" :: acc\n+\n+  where\n+    chunksMember : [Text] -> Member -> [Text]\n+    chunksMember acc (k,v) = chunks (\": \" :: (show k :: acc)) v\n+\n+\n+-- Parse a string into JSON\n+parse : Text -> Json\n+parse = parseWith json\n+\n+\n+-- JSON gramar, following: https://www.json.org/json-en.html\n+\n+json : Par Json\n+json = do ws; fixP (\\element -> recursiveStructure element)\n+\n+recursiveStructure : Par Json -> Par Json\n+recursiveStructure element0 = element where\n+\n+  value,object,array,element : Par Json\n+  elements : Par [Json]\n+  members : Par [Member]\n+  member : Par Member\n+\n+  element = do\n+    v <- value\n+    ws; return v\n+\n+  value = alts [object,array,string,number,true,false,null]\n+\n+  object = do\n+    char \"{\"\n+    ws; ms <- alts [return [], members]\n+    char \"}\"\n+    return $ Jobject ms\n+\n+  members = commaSeparated member\n+\n+  member = do\n+    s <- str\n+    ws; char \":\"\n+    ws; v <- element0\n+    return (s,v)\n+\n+  array = do\n+    char \"[\";\n+    ws; es <- alts [return [], elements]\n+    char \"]\";\n+    return $ Jarray es\n+\n+  elements = commaSeparated element0\n+\n+\n+string,number,true,false,null : Par Json\n+integer,positive : Par Int\n+str,characters,character,digit,onenine : Par Text\n+\n+true = do keyword \"true\"; return Jtrue\n+false = do keyword \"false\"; return Jfalse\n+null = do keyword \"null\"; return  Jnull\n+\n+string = Jstring <$> str\n+\n+str = do\n+  char \"\\\"\"\n+  cs <- characters\n+  char \"\\\"\"\n+  return cs\n+\n+characters = implode <$> many character\n+\n+character = satisfy $ \\c ->\n+  c >= \" \" && c `notElem` [\"\\\"\",\"\\\\\"] -- escaping not supported\n+\n+number = Jnumber <$> integer -- fraction/exponent not supported\n+\n+integer = alts\n+  [ positive\n+  , do char \"-\"; negate <$> positive\n+  ]\n+\n+positive = (fromSome . parseInt) <$> alts\n+  [ do char \"0\"; return \"0\"\n+  , do d <- onenine; ds <- many digit; return (d <> implode ds)\n+  ]\n+\n+digit = satisfy $ \\c -> c >= \"0\" && c <= \"9\"\n+onenine = satisfy $ \\c -> c >= \"1\" && c <= \"9\"\n+\n+\n+commaSeparated : Par a -> Par [a]\n+commaSeparated thing = do\n+  x <- thing\n+  xs <- alts [return [], do char \",\"; ws; commaSeparated thing]\n+  return (x::xs)\n+\n+ws : Par ()\n+ws = fixP $ \\ws -> alts\n+  [ return ()\n+  , do char \" \"; ws\n+  , do char \"\\n\"; ws\n+  , do char \"\\t\"; ws\n+  ]\n+\n+keyword : Text -> Par ()\n+keyword t = chars (explode t)\n+\n+chars : [Text] -> Par ()\n+chars [] = return ()\n+chars (x::xs) = do char x; chars xs\n+\n+char : Text -> Par ()\n+char x = do _ <- satisfy (== x); return ()\n+\n+alts : [Par a] -> Par a\n+alts = foldl altP failP\n+\n+many : Par a -> Par [a]\n+many thing = alts [return [], do x <- thing; xs <- many thing; return (x::xs)]\n+\n+\n+instance Functor Par where fmap f p = p >>= return . f\n+instance Applicative Par where pure = retP; (<*>) = ap\n+instance Action Par where (>>=) = bindP\n+\n+\n+-- Parser combinators, in continuation passing style.\n+\n+newtype Par a = Par (forall b. Chars -> K4 a b -> Res b)"
  }
]