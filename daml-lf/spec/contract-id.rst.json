[
  {
    "id" : "d1b123dd-0aa7-4b4a-9603-41332eb14b4d",
    "prId" : 5991,
    "comments" : [
      {
        "id" : "0b1931d9-1e48-4447-908f-d26bf2fe781b",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\nDepending on the ledger implementation, the local contract IDs are\r\n```",
        "createdAt" : "2020-05-25T08:31:03Z",
        "updatedAt" : "2020-05-25T08:54:03Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d70cbbf83f8ff0e01b793b887f877d8f61f7294",
    "line" : null,
    "diffHunk" : "@@ -206,13 +206,13 @@ The submission performs the following steps:\n   discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n   interpretation. The submitter can restart the interpretation, which will pick\n   another submission seed.\n-* If the transaction succeeds, the output is a *raw transaction*\n+* If the transaction succeeds, the output is a *submitted transaction*\n \n \n Depending of the ledger implementation, the local contract IDs are"
  },
  {
    "id" : "4c43b2f6-3106-445e-80ce-a5eca8a9b928",
    "prId" : 5991,
    "comments" : [
      {
        "id" : "72bb46b4-757a-4456-a87c-27915166014a",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\nsuffixed with a suffix in a later step. This yields the *committed\r\n```",
        "createdAt" : "2020-05-25T08:32:14Z",
        "updatedAt" : "2020-05-25T08:54:03Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d70cbbf83f8ff0e01b793b887f877d8f61f7294",
    "line" : null,
    "diffHunk" : "@@ -206,13 +206,13 @@ The submission performs the following steps:\n   discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n   interpretation. The submitter can restart the interpretation, which will pick\n   another submission seed.\n-* If the transaction succeeds, the output is a *raw transaction*\n+* If the transaction succeeds, the output is a *submitted transaction*\n \n \n Depending of the ledger implementation, the local contract IDs are\n-suffixed with a suffix in a latter step. This yields the *ready\n-transaction*. For ledgers that do not require suffixing, raw and ready\n-transaction coincide. Ready transactions are the source of true to\n+suffixed with a suffix in a latter step. This yields the *committed"
  },
  {
    "id" : "68a3d7f0-6ea8-4d25-8402-69388d79b3e1",
    "prId" : 5991,
    "comments" : [
      {
        "id" : "c562a9eb-c2ee-4f1b-baf6-fabbc7d34de5",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\ntransactions coincide. Committed transactions are the source of truth to\r\n```",
        "createdAt" : "2020-05-25T08:33:39Z",
        "updatedAt" : "2020-05-25T08:54:03Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d70cbbf83f8ff0e01b793b887f877d8f61f7294",
    "line" : null,
    "diffHunk" : "@@ -206,13 +206,13 @@ The submission performs the following steps:\n   discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n   interpretation. The submitter can restart the interpretation, which will pick\n   another submission seed.\n-* If the transaction succeeds, the output is a *raw transaction*\n+* If the transaction succeeds, the output is a *submitted transaction*\n \n \n Depending of the ledger implementation, the local contract IDs are\n-suffixed with a suffix in a latter step. This yields the *ready\n-transaction*. For ledgers that do not require suffixing, raw and ready\n-transaction coincide. Ready transactions are the source of true to\n+suffixed with a suffix in a latter step. This yields the *committed\n+transaction*. For ledgers that do not require suffixing, committed and submitted\n+transaction coincide. Committed transactions are the source of true to"
  },
  {
    "id" : "2c17b3c4-33e6-410a-988a-15ab100965cc",
    "prId" : 5991,
    "comments" : [
      {
        "id" : "49b6729d-9d45-4828-9e02-bac65a0c70bd",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\nderive the state of the ledger.\r\n```",
        "createdAt" : "2020-05-25T08:33:53Z",
        "updatedAt" : "2020-05-25T08:54:03Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d70cbbf83f8ff0e01b793b887f877d8f61f7294",
    "line" : null,
    "diffHunk" : "@@ -206,13 +206,13 @@ The submission performs the following steps:\n   discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n   interpretation. The submitter can restart the interpretation, which will pick\n   another submission seed.\n-* If the transaction succeeds, the output is a *raw transaction*\n+* If the transaction succeeds, the output is a *submitted transaction*\n \n \n Depending of the ledger implementation, the local contract IDs are\n-suffixed with a suffix in a latter step. This yields the *ready\n-transaction*. For ledgers that do not require suffixing, raw and ready\n-transaction coincide. Ready transactions are the source of true to\n+suffixed with a suffix in a latter step. This yields the *committed\n+transaction*. For ledgers that do not require suffixing, committed and submitted\n+transaction coincide. Committed transactions are the source of true to\n describe the state if the ledger."
  },
  {
    "id" : "d0c41176-d406-4fa2-b70c-ff3d86b0ea96",
    "prId" : 5876,
    "comments" : [
      {
        "id" : "0489d2af-760c-46e0-a54f-10946a3153c6",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "in #5784 @hurryabit wrote:\r\n> Should it be `versionPrefix`? If so, the same type happened further below again.",
        "createdAt" : "2020-05-06T18:10:53Z",
        "updatedAt" : "2020-05-06T18:10:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fa0dd383-3d86-4d02-bf1a-e7433f4c592c",
        "parentId" : "0489d2af-760c-46e0-a54f-10946a3153c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "good catch. ",
        "createdAt" : "2020-05-06T18:11:15Z",
        "updatedAt" : "2020-05-06T18:11:15Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a986d2bbeb660bd1f4ff36a1909e53966b144273",
    "line" : 15,
    "diffHunk" : "@@ -45,18 +46,18 @@ Contract Identifiers\n A *contract identifier* (or contract ID for short) is a sequence of\n bytes defined as follows ::\n \n-  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+  ContractID := versionPrefix ∥ discriminator ∥ suffix"
  },
  {
    "id" : "c28e88f7-1bc9-4dee-9fc7-e0148f51983b",
    "prId" : 5876,
    "comments" : [
      {
        "id" : "24c9fae3-570f-414d-9bb1-6970d1e595a4",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In #5784 @hurryabit commented:\r\n> Doesn't it say 96 in the DAML-LF 1 spec?",
        "createdAt" : "2020-05-06T18:11:54Z",
        "updatedAt" : "2020-05-06T18:11:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1e040265-eee5-44fe-9485-5c49b615f40d",
        "parentId" : "24c9fae3-570f-414d-9bb1-6970d1e595a4",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "The spec indeed said `96` before #5784, but it said after `94`. \r\nWith `94` for the suffix, contract Id are at most 127 bytes long. \r\nThis is the maximal length, to make the hexadecimal encoding less that 254 (the old limit for contract Id).\r\nI fixed the 95.\r\n\r\n",
        "createdAt" : "2020-05-06T18:22:29Z",
        "updatedAt" : "2020-05-06T18:22:29Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a986d2bbeb660bd1f4ff36a1909e53966b144273",
    "line" : 27,
    "diffHunk" : "@@ -45,18 +46,18 @@ Contract Identifiers\n A *contract identifier* (or contract ID for short) is a sequence of\n bytes defined as follows ::\n \n-  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+  ContractID := versionPrefix ∥ discriminator ∥ suffix\n \n where\n \n * ``∥`` is the concatenation operation; \n-* ``verisionPrefix`` is 1 byte (equal to 0) used to version the\n+* ``versionPrefix`` is 1 byte (equal to 0) used to version the\n   contract ID scheme;\n * ``discriminator`` is a sequence of 32 bytes. It is like a random\n   UUID, but generated from an initial seed (called *submission seed*)\n   via a fixed `derivation scheme <Allocation scheme for\n   discriminators_>`_ that supports validation (see below).\n-* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global"
  },
  {
    "id" : "3c16ff3b-b644-4167-b4e9-5ca58f0d2cf5",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "66d7736a-f74d-4f0f-bf34-b905d08d4af3",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* Allows ledgers to store arbitrary information about the contract and the creating transaction in the contract ID if necessary.\r\n\r\n```",
        "createdAt" : "2020-05-04T08:11:24Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 14,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+"
  },
  {
    "id" : "fd40877f-35f8-460e-8c68-7d04c135749f",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "d44ab63b-4985-4bb3-9623-0d910fd21c96",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "This is the first time in this document that you mention \"input seeds\". Can you explain them briefly here or put a forward reference to their definition?",
        "createdAt" : "2020-05-04T08:13:02Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3de6429e-88aa-46c5-9a95-ca1b3a467f5d",
        "parentId" : "d44ab63b-4985-4bb3-9623-0d910fd21c96",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I drop the \"input seeds\". I just consider the seed of the node to be part of the projection. ",
        "createdAt" : "2020-05-05T12:26:42Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 24,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds."
  },
  {
    "id" : "9407d673-443a-4c9f-a955-c32bfbdb270b",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "77924a25-b621-45a2-a5c6-b74ede47b938",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "As is this is too strong. Given that transactions are small in size, an adversary that knows just the input seed used for the transaction that creates a contract could derive seeds for all potential nodes in the tree and then validate its guess of the signatories by recomputing the discriminators.\r\n```suggestion\r\ncontents to the contract ID unless the create node is witnessed or the input seeds are known. The\r\n```",
        "createdAt" : "2020-05-04T08:34:58Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The"
  },
  {
    "id" : "6e04cd4b-0884-431f-a17b-bc8469f276b7",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "b7e78832-a26b-41fa-a6a8-7186659f6c88",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* ``verisionPrefix`` is 1 byte (equal to 0) used to version the\r\n```",
        "createdAt" : "2020-05-04T08:42:40Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the"
  },
  {
    "id" : "c3fd1db9-4f9b-40f8-8ceb-96d6c6783723",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "6390beed-2435-4425-845a-999ee8838e8a",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* ``discriminator`` is a sequence of 32 bytes. It is generated from an initial seed (called *submission seed*)\r\n```\r\nI'd try to avoid the technical term \"UUID\" because there's a standard that describes the precise format. In particular, a UUID consists of exactly 16 bytes.",
        "createdAt" : "2020-05-04T08:47:02Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 56,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)"
  },
  {
    "id" : "2efdaef5-d700-4862-94cd-e7fda31fba74",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "181ca7c1-11ea-496c-bdf6-f25b8200a6c3",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Is this enforced in the implementation anywhere? In our tests, even very long suffixes seem to be accepted: https://github.com/DACH-NY/canton/blob/master/common/src/test/scala/com/digitalasset/canton/protocol/ContractIdTest.scala#L70",
        "createdAt" : "2020-05-04T08:48:37Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7031a4f6-004a-469f-bdd9-7588bf53effe",
        "parentId" : "181ca7c1-11ea-496c-bdf6-f25b8200a6c3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "It is specified in the [DAML-LF spec](https://github.com/digital-asset/daml/blob/remy-contract-id-spec/daml-lf/spec/daml-lf-1.rst) line 564 (with a typo :().\r\nI will fix the typo and add a check in a upcoming PR. \r\n",
        "createdAt" : "2020-05-04T17:04:57Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 60,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger."
  },
  {
    "id" : "d31969a8-3b54-442f-900f-2c92e598529d",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "d3f9d23e-548b-4810-96a6-580a11c7f455",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nIn a transaction we distinguish two kinds of contract IDs:\r\n```",
        "createdAt" : "2020-05-04T08:48:56Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:"
  },
  {
    "id" : "7cd173a6-ea79-44a3-bf75-4e2e6123e07e",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "ca62385f-637a-4580-a831-095f62c92143",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* The *global* contract IDs are the contract IDs that:\r\n```",
        "createdAt" : "2020-05-04T08:49:20Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:"
  },
  {
    "id" : "9d6d8bb4-5fb4-4378-bcbc-748f8c4df7bf",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "3bf295ac-6ac3-4502-b63e-89ba558dd106",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n   * appear in the commands that produced the transaction. This\r\n```",
        "createdAt" : "2020-05-04T08:49:33Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This"
  },
  {
    "id" : "f512f1b1-9d07-4afd-b75e-f802557aec3f",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "0f27e9cb-a1bf-4f53-b2bb-88c8e3020be7",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n   * that are fetched or looked up by key unless they are local;\r\n```\r\nA local contract may be the result of a `fetchByKey`, but we don't want it to be global, do we?",
        "createdAt" : "2020-05-04T08:50:54Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;"
  },
  {
    "id" : "1b986464-d2ad-4353-91d8-633820bc590b",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "006cf1dd-e0aa-44c0-9c90-a681a11616c9",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nsubmitter has referenced in its submission.\r\n```",
        "createdAt" : "2020-05-04T08:51:30Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission."
  },
  {
    "id" : "8a197776-b6a6-45c8-abd3-9a0f733aa6b8",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "ed1cf2a2-a045-48d6-8c66-926386fc7bfe",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nto order the contract IDs of created contracts w.r.t. other contract\r\n```",
        "createdAt" : "2020-05-04T08:51:58Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract"
  },
  {
    "id" : "799286f0-8ad7-4b7f-87dd-fe2aeca95090",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "708ff389-5d9f-4bae-b39d-6c86050c70e8",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I think this does not really cover Corda's use of suffixes, namely storing additional information in the contract ID. How about the following?\r\n\r\n```suggestion\r\nLedger implementations are responsible for enforcing \r\nuniqueness of contract IDs on the whole ledger.\r\nThis can be done by enforcing global uniqueness of the seeds or by appropriately suffixing the contract IDs.\r\nNo other requirement (except the 95 bytes size\r\nlimit) is assumed for those suffices.\r\n```",
        "createdAt" : "2020-05-04T09:01:08Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices."
  },
  {
    "id" : "f66f169c-be88-4485-880e-032c93dcddb1",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "64498b2b-ea7a-43c4-a806-2da5500eac71",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Suffixes do not guard against lack of entropy, because the low entropy remains in the discriminators. So unlinkability remains broken if entropy is low, even with suffixes. I suggest to remove this sentence.",
        "createdAt" : "2020-05-04T09:03:11Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "553d9ef2-b2b1-41d3-a5a9-f756468d5839",
        "parentId" : "64498b2b-ea7a-43c4-a806-2da5500eac71",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped",
        "createdAt" : "2020-05-05T08:57:42Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dde1a100-14b1-48e7-92ce-c1c40a32b8e5",
        "parentId" : "64498b2b-ea7a-43c4-a806-2da5500eac71",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped",
        "createdAt" : "2020-05-05T09:00:37Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. "
  },
  {
    "id" : "af745d3d-894c-4f8c-8a33-291b22051b94",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "2684ee19-be2f-4a6e-a509-8b09ed6b1a41",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\npractice, it should be close to the original time at which the\r\n```",
        "createdAt" : "2020-05-04T09:03:58Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the"
  },
  {
    "id" : "0a19edf7-871f-43b7-8c5b-b451e29c1345",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "8293f62b-da58-41cb-9fc2-ce5ad1968b1a",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nledger to enforce global uniqueness of the pair (submission seed,\r\n```",
        "createdAt" : "2020-05-04T09:04:07Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,"
  },
  {
    "id" : "24235325-7d39-40e8-a3b9-8123b1ac064f",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "5228c98c-b3ff-4e7c-8fdf-050c95a58a09",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nfor all Create and Exercise nodes in the transaction tree are derived as they are\r\n```\r\nFetch and LookupByKey don't really get seeds, do they?",
        "createdAt" : "2020-05-04T09:10:33Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are"
  },
  {
    "id" : "4b64727b-8fec-457b-9a34-23a3e9ce339b",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "ab73a1f9-93f7-41f9-a987-a373128bdc5d",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nfor each big-endian 32 bits integer ``n`` the derived seed:\r\n```",
        "createdAt" : "2020-05-04T09:10:51Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::"
  },
  {
    "id" : "6d4dcabd-3ba0-4c67-91dc-aa1df419ea8c",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "2595acd1-3434-4396-956a-9b691fc39a0f",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "`participantId` is a ledger string, i.e., of varying length. In the above notation, I do not see that the length of `participantId` is included in the argument to `HMAC`. If it isn't, we may get hash collissions because `submitters` too is a variable-length string. In the implementation I see that the actual derivation adds the length of the participantId to the string. Can you also do so here? ",
        "createdAt" : "2020-05-04T09:16:10Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0924a3da-82be-4a5d-b9a8-74b12565420b",
        "parentId" : "2595acd1-3434-4396-956a-9b691fc39a0f",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Found the comment below about the length prefix.",
        "createdAt" : "2020-05-04T09:18:11Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)"
  },
  {
    "id" : "af6e7ed5-cd37-4c16-8b29-8aa5864ee8b4",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "93790ed1-533d-4dbb-b9e6-0ed9ce121a26",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "`Engine.deriveTransactionSeed` doesn't include the submitters. https://github.com/digital-asset/daml/blob/master/daml-lf/engine/src/main/scala/com/digitalasset/daml/lf/engine/Engine.scala#L391 So maybe remove them here too?",
        "createdAt" : "2020-05-04T09:17:48Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a417f1ea-09df-4d75-9ebe-0a258638dfa6",
        "parentId" : "93790ed1-533d-4dbb-b9e6-0ed9ce121a26",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "good catch. \r\nIt is removed.",
        "createdAt" : "2020-05-05T09:06:40Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :="
  },
  {
    "id" : "b434c852-c8f6-47c7-8b3a-fbdfb2eaa2bc",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "d9505db4-778a-4a6e-b7dd-4feba2918bf5",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Is the size prefix included when the submitters are sorted lexicographically?",
        "createdAt" : "2020-05-04T09:19:18Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bebd9223-dc39-41af-91b3-277d36cd415e",
        "parentId" : "d9505db4-778a-4a6e-b7dd-4feba2918bf5",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Yes. always you get collision for sumittes (`a`, `aaaa`) and (`aa, `aaa`).\r\n\r\nConcretely  (`a`, `aaaa`) is encoded as `(2 ∥ 1 ∥ a ∥ 4 ∥ aaaa)` and  (`aa, `aaa`) as  `(2 ∥ 2 ∥ aa ∥ 3 ∥ aaa)` ",
        "createdAt" : "2020-05-04T17:10:10Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer."
  },
  {
    "id" : "823baf88-a2a4-41e8-b4b5-4f98d7afd845",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "1341f44c-9516-4fba-ab9b-0380304e544a",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\nThe submission performs the following steps:\r\n```\r\nOr some other verb that you'd like to have in there.",
        "createdAt" : "2020-05-04T09:21:39Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:"
  },
  {
    "id" : "8a523181-a4f1-45a2-97a0-2990ace1ca26",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "ffd70449-1a55-40c0-b4b1-965fecbacd13",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* Pick a submission seed with high entropy.\r\n```",
        "createdAt" : "2020-05-04T09:21:55Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:\n+\n+* Peek a submission seed  with high entropy."
  },
  {
    "id" : "d96df5b6-ae5a-4dd1-bb00-85f8bb83c6d3",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "900179f2-857c-487d-9e6f-d1d9603e9282",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "According to step 1, the submission seed is picked by \"submission\". This sounds as if the submitter does not have control over the seed and therefore. This reads as if the submitter could choose the submission seed. So I recommend to either change the first step into `Submission takes a high-entropy submission seed as input` or to change this into \r\n```suggestion\r\n  interpretation. The submitter can restart the interpretation, which will pick\r\n  another submission seed.\r\n```",
        "createdAt" : "2020-05-04T09:24:10Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:\n+\n+* Peek a submission seed  with high entropy.\n+* Derive the transaction seed and start the interperation\n+* During interpretation derive the node seeds, and the discriminator\n+  of local contract ID accordingly the scheme described above.  If the\n+  discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n+  interpretation. The submitter can restart the interpretation with\n+  another submission seed."
  },
  {
    "id" : "16955890-8ff1-4d6a-9caf-74ab4dab0e6f",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "2cc65d6d-f31d-4ca6-8116-e3dff19829e2",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n* All local contract IDs in the raw transaction are suffixed with a\r\n```",
        "createdAt" : "2020-05-04T09:24:27Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:\n+\n+* Peek a submission seed  with high entropy.\n+* Derive the transaction seed and start the interperation\n+* During interpretation derive the node seeds, and the discriminator\n+  of local contract ID accordingly the scheme described above.  If the\n+  discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n+  interpretation. The submitter can restart the interpretation with\n+  another submission seed.\n+* If the transaction succeeds, the output is a *raw transaction*\n+* All local contract IDs in the raw transaction are suffix with a"
  },
  {
    "id" : "d85872da-08e6-487c-9892-fcad80f58997",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "60c270ae-ed4c-436a-b49e-756b583b5ba7",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "What is the write path? I presume that this is something else than the Write service, as the suffixing only happens after the transaction has been sent to the Write service.",
        "createdAt" : "2020-05-04T09:25:20Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27f66381-cd22-4555-af33-c56e9245dadb",
        "parentId" : "60c270ae-ed4c-436a-b49e-756b583b5ba7",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I reformulated.",
        "createdAt" : "2020-05-05T09:28:14Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:\n+\n+* Peek a submission seed  with high entropy.\n+* Derive the transaction seed and start the interperation\n+* During interpretation derive the node seeds, and the discriminator\n+  of local contract ID accordingly the scheme described above.  If the\n+  discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n+  interpretation. The submitter can restart the interpretation with\n+  another submission seed.\n+* If the transaction succeeds, the output is a *raw transaction*\n+* All local contract IDs in the raw transaction are suffix with a\n+  ledger specific suffix. This yields the *ready transaction*.\n+* The ready transaction is then sent on the write path, along with the\n+  submission seed and the submission time."
  },
  {
    "id" : "cbb05f4b-f584-424e-bec2-d2ba0e546e31",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "3d3a991e-2d66-47e6-a22a-ec3a4854443b",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\ntransaction, the submission seed, and the submission time as\r\n```",
        "createdAt" : "2020-05-04T09:25:38Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a\n+32 bits big-endian integer.\n+  \n+     \n+Derivation of seeds for root nodes the transaction\n+--------------------------------------------------\n+\n+For each root node of the transaction, a root seed `rootSeedᵢ` is\n+computed from the initial seed as follows::\n+\n+  rootSeedᵢ = deriveSeed(transactionSeed, i)\n+\n+Derivation of seeds for the children of exercise nodes\n+------------------------------------------------------\n+\n+For an exercise node with seed ``nodeSeed``, the seeds `childSeedᵢ` for the\n+children are derived as follows::\n+\n+  childSeedᵢ = deriveSeed(nodeSeed, i)\n+\n+Derivation of contract ID discriminator\n+---------------------------------------\n+\n+The discriminator for the created contract ID is given as follows::\n+\n+  discriminator = HMAC(nodeSeed, submissionTime ∥ nₛ ∥ stackholders) \n+\n+where\n+\n+* ``nodeSeed`` is the seed of the node where the contract is created;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of stakeholder's of the contract encoded as a\n+  32 bits big-endian integer;\n+* ``stackholders`` is the concatenation of the stakeholders IDs sorted\n+  lexicographically.\n+\n+IDs of stakeholder are interpreted as their US-ASCII encoding prefixed\n+with there size encoded as a 32 bits  big-endian integer.\n+  \n+Submission\n+^^^^^^^^^^\n+\n+The submission the following steps:\n+\n+* Peek a submission seed  with high entropy.\n+* Derive the transaction seed and start the interperation\n+* During interpretation derive the node seeds, and the discriminator\n+  of local contract ID accordingly the scheme described above.  If the\n+  discriminator is not `fresh <Discriminator Freshness_>`_, abort the\n+  interpretation. The submitter can restart the interpretation with\n+  another submission seed.\n+* If the transaction succeeds, the output is a *raw transaction*\n+* All local contract IDs in the raw transaction are suffix with a\n+  ledger specific suffix. This yields the *ready transaction*.\n+* The ready transaction is then sent on the write path, along with the\n+  submission seed and the submission time.\n+\n+Validation\n+^^^^^^^^^^\n+\n+Reinterpretation for a full transaction validation takes the\n+transition, the submission seed, and the submission time as"
  },
  {
    "id" : "c4aafbce-f088-4854-8fcf-d897b520b386",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "356e01a2-ee9b-43bd-ab02-1f426553af62",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\ntheir US-ASCII encoding prefixed with their size encoded as a\r\n```",
        "createdAt" : "2020-05-04T17:07:11Z",
        "updatedAt" : "2020-05-05T12:28:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,245 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to versioned the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global\n+  uniqueness of the contract ID in a distributed ledger.\n+\n+Discriminator freshness\n+-----------------------\n+\n+In a transaction we distinct two kinds of contract IDs:\n+\n+* The *local* contract IDs are the IDs of the contracts created by the\n+  transaction.\n+\n+*  The *global* contract IDs are the contract IDs that:\n+   \n+   * appears in the commands that produced the transaction. This\n+     includes the IDs of the exercised contract, together with all the\n+     IDs referenced in the arguments of the create and exercise\n+     commands;\n+   * that are fetched or looked up by key;\n+   * are referenced in the input contracts.\n+\n+Note that local contract IDs correspond to the ID of output contracts\n+together with those contracts that have been created and archived in\n+the transaction. On the other hand, global contract IDs do not\n+reference only IDs of some contracts that have been previously\n+persisted on the ledger, but also any arbitrary contract IDs that the\n+submitter have referenced in its submission.\n+\n+The so-called *discriminator freshness condition* holds if the\n+discriminators from local contract IDs are distinct from the\n+discriminators from global contract IDs.\n+\n+This ensures that only the discriminators, not the suffix are needed\n+to order the contract IDs of created contract w.r.t. other contract\n+IDs. \n+\n+Contract ID uniqueness\n+----------------------\n+\n+During interpretation local contract IDs are created without suffix.\n+It is the responsibility of the ledger implementation to provide for\n+each local contract ID a suffix that guarantee global uniqueness of\n+the whole contract ID. No other requirement (except the 95 bytes size\n+limit) is assumed for those suffices.\n+\n+This guard against the submitter choosing low-entropy submission seeds. \n+\n+The simplest approach consists to suffix all local contract ID with a\n+uniquely global transaction ID. Alternatively central commiter ledger\n+can completely avoid suffixing by enforcing that same pair (submission\n+seed, submission time) is never used more that once, the discriminator\n+allocation scheme ensuring in this case the uniqueness of allocated\n+discriminators.\n+\n+Submission time\n+---------------\n+\n+The submission time is used to derive the transaction seed. In\n+practice, it should be closed to the original time at which the\n+submission was initiated. No particular requirement is made in this\n+specification. However a particular ledger implementation can require\n+this time to be within a particular time window around the commit\n+time. This allows, for instance, the commiter of a central commiter\n+ledger to en enforce global uniqueness of the pair (submission seed,\n+submission time).\n+\n+Allocation scheme for discriminators\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  \n+From an initial seed, called in the following *submission seed*, seeds\n+for all nodes in the transaction tree are derived as they are\n+computed.\n+\n+We propose the following scheme, inspired by NIST’s HMAC_DRBG\n+construction. It assumes a hash-based MAC function HMAC, and defines\n+for each big-endian 32 bits integer ``n`` the derived seed::\n+\n+  deriveSeed(seed, n) := HMAC(seed, n)\n+  \n+\n+Submission seed\n+---------------\n+\n+Any random number with sufficient entropy works as submission seed\n+``submission_seed`` (256 bit entropy).\n+\n+Transaction seed construction\n+-----------------------------\n+\n+From the submission, a so-called *transaction seed* is derived as follows::\n+\n+  deriveTransactionSeed(submissionSeed, participandId, submissionTime, submitters) :=\n+     HMAC(submissionSeed, participantId ∥ submissionTime ∥ nₛ ∥ submitters)\n+\n+where\n+\n+* ``submissionSeed`` is the submission seed;\n+* ``participandId`` is the participant ID;\n+* ``submissionTime`` is the submission time in micro second encoded as\n+  a 64 bytes big-endian integer;\n+* ``nₛ`` is the number of submitters encoded as a 32 big-endian bits\n+  integer;\n+* ``submitters`` is the concatenation of the submitter IDs sorted\n+  lexicographically.\n+\n+Strings such as participant IDs or submitter IDs are interpreted as\n+their US-ASCII encoding prefixed with there size encoded as a"
  },
  {
    "id" : "1bfa7d84-2a2e-4ba5-9530-b0da799d83b9",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "bb45d6cc-ec91-4d4a-8478-8ea5a85214bf",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Should it be `versionPrefix`? If so, the same type happened further below again.",
        "createdAt" : "2020-05-06T16:11:18Z",
        "updatedAt" : "2020-05-06T16:22:43Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 48,
    "diffHunk" : "@@ -0,0 +1,242 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+* Allows ledgers to store arbitrary information about the contract and the creating transaction in the contract ID if necessary.\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed or the input seeds are known. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  "
  },
  {
    "id" : "8f50cf1c-052a-493f-9f94-c3ed4f30086b",
    "prId" : 5784,
    "comments" : [
      {
        "id" : "7f1390f6-6dd4-496c-b4bc-344d5f629e79",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Doesn't it say 96 in the DAML-LF 1 spec?",
        "createdAt" : "2020-05-06T16:21:47Z",
        "updatedAt" : "2020-05-06T16:22:43Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1740b4aad8b549fda29ee37d8663f4d503545a20",
    "line" : 59,
    "diffHunk" : "@@ -0,0 +1,242 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+V1 Contract ID allocation scheme\n+================================\n+\n+Goals\n+^^^^^\n+\n+* Allows ordering contract IDs and make DAML semantics depend on this\n+  order, e.g., for comparison builtin and maps using IDs as keys.\n+* Eliminate all contract ID translations for central commiter ledger\n+* Allows ledgers to store arbitrary information about the contract and the creating transaction in the contract ID if necessary.\n+\n+Requirements\n+^^^^^^^^^^^^\n+\n+**Executability**: DAML engine can determine ordering of the contract\n+IDs before it hands out the transaction to the write service.\n+\n+**Validation**: The allocation scheme commutes with transaction\n+projection. That is, the contract IDs for contracts created in the\n+projection of a transaction to a set of parties can be computed\n+solely from the projection and input seeds.\n+\n+**Unlinkability**: It is computationally infeasible to link the contract\n+contents to the contract ID unless the create node is witnessed or the input seeds are known. The\n+contract contents include the contract instance, the template ID, the\n+stakeholders / signatories / maintainers, and the contract key.\n+\n+**Freshness**: It is computationally infeasible to find contracts C1 and\n+C2 with the same contract ID such that one of the following holds:\n+\n+* The contracts have different stakeholders.\n+* The contracts are created by different transactions.\n+* The contracts are created by different subactions of the same\n+  transaction forest where the seeds are pairwise different.\n+\n+**Distinctness**: The ledger can enforce that the seeds are pairwise\n+different.\n+\n+Contract Identifiers\n+^^^^^^^^^^^^^^^^^^^^\n+\n+A *contract identifier* (or contract ID for short) is a sequence of\n+bytes defined as follows ::\n+\n+  ContractID := verisionPrefix ∥ discriminator ∥ suffix  \n+\n+where\n+\n+* ``∥`` is the concatenation operation; \n+* ``verisionPrefix`` is 1 byte (equal to 0) used to version the\n+  contract ID scheme;\n+* ``discriminator`` is a sequence of 32 bytes. It is like a random\n+  UUID, but generated from an initial seed (called *submission seed*)\n+  via a fixed `derivation scheme <Allocation scheme for\n+  discriminators_>`_ that supports validation (see below).\n+* ``suffix`` is a sequence of 0 to 95 bytes used to enforce global"
  }
]